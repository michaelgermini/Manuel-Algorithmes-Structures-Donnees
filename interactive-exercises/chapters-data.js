// Donn√©es des chapitres - g√©n√©r√© automatiquement
const chaptersData = {
  "02": "# Chapitre 2 : Tableaux et Algorithmes de Tri\n\n## üìä Les Tableaux en JavaScript\n\n### D√©finition et D√©claration\n\nUn **tableau** (array) est une structure de donn√©es qui stocke une collection ordonn√©e d'√©l√©ments.\n\n```javascript\n// D√©claration d'un tableau vide\nlet tableauVide = [];\n\n// Tableau avec des √©l√©ments\nlet nombres = [1, 2, 3, 4, 5];\nlet fruits = [\"pomme\", \"banane\", \"orange\"];\n\n// Tableau mixte (possible en JS, mais d√©conseill√©)\nlet mixte = [1, \"hello\", true, null];\n```\n\n### üßÆ Op√©rations de Base\n\n#### Acc√®s aux √âl√©ments\n```javascript\nlet nombres = [10, 20, 30, 40, 50];\n\n// Acc√®s par index (commence √† 0)\nconsole.log(nombres[0]);  // 10 (premier √©l√©ment)\nconsole.log(nombres[2]);  // 30 (troisi√®me √©l√©ment)\nconsole.log(nombres[nombres.length - 1]); // 50 (dernier √©l√©ment)\n```\n\n#### Modification d'√âl√©ments\n```javascript\nlet nombres = [10, 20, 30];\nnombres[1] = 25;  // Remplace 20 par 25\nconsole.log(nombres); // [10, 25, 30]\n```\n\n#### Ajout et Suppression\n```javascript\nlet fruits = [\"pomme\", \"banane\"];\n\n// Ajout √† la fin\nfruits.push(\"orange\");\nconsole.log(fruits); // [\"pomme\", \"banane\", \"orange\"]\n\n// Suppression du dernier √©l√©ment\nlet dernier = fruits.pop();\nconsole.log(dernier); // \"orange\"\nconsole.log(fruits); // [\"pomme\", \"banane\"]\n\n// Ajout au d√©but\nfruits.unshift(\"fraise\");\nconsole.log(fruits); // [\"fraise\", \"pomme\", \"banane\"]\n\n// Suppression du premier √©l√©ment\nlet premier = fruits.shift();\nconsole.log(premier); // \"fraise\"\nconsole.log(fruits); // [\"pomme\", \"banane\"]\n```\n\n### üîç Algorithmes de Base sur les Tableaux\n\n#### Recherche Lin√©aire\n```javascript\nfunction rechercheLineaire(arr, cible) {\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] === cible) {\n            return i; // Retourne l'index\n        }\n    }\n    return -1; // Non trouv√©\n}\n\nconsole.log(rechercheLineaire([1, 3, 5, 7, 9], 5)); // 2\nconsole.log(rechercheLineaire([1, 3, 5, 7, 9], 4)); // -1\n```\n**Complexit√©** : O(n)\n\n#### Calcul de Somme\n```javascript\nfunction sommeTableau(arr) {\n    let somme = 0;\n    for (let nombre of arr) {\n        somme += nombre;\n    }\n    return somme;\n}\n\nconsole.log(sommeTableau([1, 2, 3, 4])); // 10\n```\n**Complexit√©** : O(n)\n\n#### Recherche du Maximum\n```javascript\nfunction maximumTableau(arr) {\n    if (arr.length === 0) return undefined;\n\n    let max = arr[0];\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\nconsole.log(maximumTableau([3, 1, 8, 2, 5])); // 8\n```\n**Complexit√©** : O(n)\n\n---\n\n## üîÑ Algorithmes de Tri\n\n### üéØ Tri par Insertion (Insertion Sort)\n\n**Principe** : Construit le tableau tri√© √©l√©ment par √©l√©ment.\n\n```javascript\nfunction triInsertion(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        let cle = arr[i];\n        let j = i - 1;\n\n        // D√©caler les √©l√©ments plus grands que la cl√©\n        while (j >= 0 && arr[j] > cle) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n\n        arr[j + 1] = cle;\n    }\n    return arr;\n}\n\n// Exemple\nlet tableau = [12, 11, 13, 5, 6];\nconsole.log(triInsertion(tableau)); // [5, 6, 11, 12, 13]\n```\n\n**Complexit√©** :\n- Meilleur cas : O(n) - tableau d√©j√† tri√©\n- Pire cas : O(n¬≤) - tableau tri√© en ordre inverse\n- Cas moyen : O(n¬≤)\n\n### ü´ß Tri √† Bulles (Bubble Sort)\n\n**Principe** : Compare et √©change les √©l√©ments adjacents.\n\n```javascript\nfunction triBulles(arr) {\n    let n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // √âchange\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    return arr;\n}\n\n// Exemple\nlet tableau = [64, 34, 25, 12, 22, 11, 90];\nconsole.log(triBulles(tableau)); // [11, 12, 22, 25, 34, 64, 90]\n```\n\n**Complexit√©** : O(n¬≤) dans tous les cas\n\n### ‚ö° Tri Rapide (QuickSort)\n\n**Principe** : Diviser pour r√©gner - choisit un pivot et partitionne.\n\n```javascript\nfunction triRapide(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n\n    const pivot = arr[arr.length - 1];\n    const gauche = [];\n    const droite = [];\n\n    for (let i = 0; i < arr.length - 1; i++) {\n        if (arr[i] < pivot) {\n            gauche.push(arr[i]);\n        } else {\n            droite.push(arr[i]);\n        }\n    }\n\n    return [...triRapide(gauche), pivot, ...triRapide(droite)];\n}\n\n// Exemple\nlet tableau = [10, 7, 8, 9, 1, 5];\nconsole.log(triRapide(tableau)); // [1, 5, 7, 8, 9, 10]\n```\n\n**Complexit√©** :\n- Meilleur cas : O(n log n)\n- Pire cas : O(n¬≤) - quand le pivot est toujours l'√©l√©ment extr√™me\n- Cas moyen : O(n log n)\n\n### üîÄ Tri Fusion (Merge Sort)\n\n**Principe** : Divise le tableau en deux, trie r√©cursivement, puis fusionne.\n\n```javascript\nfunction triFusion(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n\n    const milieu = Math.floor(arr.length / 2);\n    const gauche = arr.slice(0, milieu);\n    const droite = arr.slice(milieu);\n\n    return fusion(triFusion(gauche), triFusion(droite));\n}\n\nfunction fusion(gauche, droite) {\n    let resultat = [];\n    let i = 0, j = 0;\n\n    while (i < gauche.length && j < droite.length) {\n        if (gauche[i] < droite[j]) {\n            resultat.push(gauche[i]);\n            i++;\n        } else {\n            resultat.push(droite[j]);\n            j++;\n        }\n    }\n\n    // Ajouter les √©l√©ments restants\n    return resultat.concat(gauche.slice(i)).concat(droite.slice(j));\n}\n\n// Exemple\nlet tableau = [12, 11, 13, 5, 6, 7];\nconsole.log(triFusion(tableau)); // [5, 6, 7, 11, 12, 13]\n```\n\n**Complexit√©** : O(n log n) dans tous les cas\n\n---\n\n## üìä Comparaison des Algorithmes de Tri\n\n| Algorithme | Meilleur | Moyen | Pire | Stable | Complexit√© Espace |\n|------------|----------|-------|------|--------|-------------------|\n| **Insertion** | O(n) | O(n¬≤) | O(n¬≤) | ‚úÖ | O(1) |\n| **Bulles** | O(n) | O(n¬≤) | O(n¬≤) | ‚úÖ | O(1) |\n| **Rapide** | O(n log n) | O(n log n) | O(n¬≤) | ‚ùå | O(log n) |\n| **Fusion** | O(n log n) | O(n log n) | O(n log n) | ‚úÖ | O(n) |\n\n### üöÄ Tris Lin√©aires\n\n#### Tri par Comptage (Counting Sort)\n\n**Principe** : Compte les occurrences de chaque valeur.\n\n```javascript\nfunction triComptage(arr) {\n    if (arr.length === 0) return arr;\n\n    // Trouver min et max\n    let min = Math.min(...arr);\n    let max = Math.max(...arr);\n\n    // Initialiser le tableau de comptage\n    let comptage = new Array(max - min + 1).fill(0);\n\n    // Compter les occurrences\n    for (let nombre of arr) {\n        comptage[nombre - min]++;\n    }\n\n    // Reconstruire le tableau tri√©\n    let resultat = [];\n    for (let i = 0; i < comptage.length; i++) {\n        for (let j = 0; j < comptage[i]; j++) {\n            resultat.push(i + min);\n        }\n    }\n\n    return resultat;\n}\n\n// Exemple\nlet tableau = [4, 2, 2, 8, 3, 3, 1];\nconsole.log(triComptage(tableau)); // [1, 2, 2, 3, 3, 4, 8]\n```\n\n**Complexit√©** : O(n + k) o√π k = plage de valeurs\n**Utilisation** : Quand la plage de valeurs est limit√©e\n\n---\n\n## üíª Exercice Pratique 1\n\n**Objectif** : Impl√©menter un tri personnalis√© pour des objets.\n\n**Consignes** :\n- Cr√©er une fonction qui trie un tableau d'objets par une propri√©t√© donn√©e\n- Utiliser un algorithme de tri de votre choix\n\n```javascript\nlet personnes = [\n    { nom: \"Alice\", age: 25 },\n    { nom: \"Bob\", age: 30 },\n    { nom: \"Charlie\", age: 20 }\n];\n\n// Trier par √¢ge croissant\nfunction trierParPropriete(arr, propriete) {\n    // TODO: impl√©menter\n}\n\nconsole.log(trierParPropriete(personnes, \"age\"));\n// R√©sultat attendu :\n// [{nom: \"Charlie\", age: 20}, {nom: \"Alice\", age: 25}, {nom: \"Bob\", age: 30}]\n```\n\n### Solution :\n```javascript\nfunction trierParPropriete(arr, propriete) {\n    return arr.slice().sort((a, b) => {\n        if (a[propriete] < b[propriete]) return -1;\n        if (a[propriete] > b[propriete]) return 1;\n        return 0;\n    });\n}\n```\n\n---\n\n## üíª Exercice Pratique 2\n\n**Objectif** : Analyser les performances des tris.\n\n**Consignes** :\n- Cr√©er une fonction qui mesure le temps d'ex√©cution d'un tri\n- Tester avec diff√©rents algorithmes et tailles de tableaux\n\n```javascript\nfunction mesurerTemps(algorithmeTri, arr) {\n    const debut = performance.now();\n    const resultat = algorithmeTri([...arr]); // Copie pour ne pas modifier l'original\n    const fin = performance.now();\n    return {\n        temps: fin - debut,\n        resultat: resultat\n    };\n}\n\n// Test avec un grand tableau\nlet grandTableau = Array.from({length: 10000}, () => Math.floor(Math.random() * 10000));\n\nconsole.log(\"Tri rapide:\", mesurerTemps(triRapide, grandTableau).temps, \"ms\");\nconsole.log(\"Tri fusion:\", mesurerTemps(triFusion, grandTableau).temps, \"ms\");\n```\n\n---\n\n### Exercice 3 : Tri √† Bulles Optimis√©\n\n**Objectif** : Impl√©menter une version optimis√©e du tri √† bulles avec d√©tection pr√©coce.\n\n**Consignes** :\n- Impl√©menter le tri √† bulles de base\n- Ajouter une optimisation : arr√™ter si aucun √©change n'a eu lieu dans un passage\n- Comparer les performances avec la version non optimis√©e\n\n```javascript\nfunction triBullesOptimise(arr) {\n    // TODO: impl√©menter la version optimis√©e\n}\n\n// Tests\nlet testArray = [64, 34, 25, 12, 22, 11, 90];\nconsole.log(\"Avant:\", testArray);\ntriBullesOptimise(testArray);\nconsole.log(\"Apr√®s:\", testArray);\n```\n\n### Solution :\n```javascript\nfunction triBullesOptimise(arr) {\n    let n = arr.length;\n    let swapped;\n\n    for (let i = 0; i < n - 1; i++) {\n        swapped = false;\n\n        // Derniers i √©l√©ments sont d√©j√† tri√©s\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // √âchange\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                swapped = true;\n            }\n        }\n\n        // Si aucun √©change n'a eu lieu, le tableau est tri√©\n        if (!swapped) {\n            break;\n        }\n    }\n}\n```\n**Am√©lioration** : Dans le meilleur cas (tableau d√©j√† tri√©), complexit√© O(n) au lieu de O(n¬≤)\n\n---\n\n### Exercice 4 : Tri par S√©lection √âtape par √âtape\n\n**Objectif** : Impl√©menter le tri par s√©lection avec tra√ßage d√©taill√©.\n\n**Consignes** :\n- Impl√©menter le tri par s√©lection\n- Afficher l'√©tat du tableau apr√®s chaque it√©ration\n- Montrer quel √©l√©ment est s√©lectionn√© comme minimum\n\n```javascript\nfunction triSelectionAvecTrace(arr) {\n    // TODO: impl√©menter avec affichage d√©taill√©\n}\n\n// Test\nlet arr = [64, 25, 12, 22, 11];\ntriSelectionAvecTrace(arr);\n```\n\n### Solution :\n```javascript\nfunction triSelectionAvecTrace(arr) {\n    console.log(\"√âtat initial:\", arr);\n\n    for (let i = 0; i < arr.length - 1; i++) {\n        let minIndex = i;\n\n        // Trouver l'√©l√©ment minimum dans la partie non tri√©e\n        for (let j = i + 1; j < arr.length; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n\n        // √âchanger avec le premier √©l√©ment non tri√©\n        if (minIndex !== i) {\n            console.log(`√âchange: ${arr[i]} ‚Üî ${arr[minIndex]} (indices ${i} ‚Üî ${minIndex})`);\n            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n        } else {\n            console.log(`Pas d'√©change n√©cessaire (position ${i} est d√©j√† minimum)`);\n        }\n\n        console.log(`Apr√®s it√©ration ${i + 1}:`, arr);\n        console.log(`Partie tri√©e: [${arr.slice(0, i + 1).join(', ')}]`);\n        console.log(\"---\");\n    }\n\n    console.log(\"Tri termin√©:\", arr);\n}\n```\n**Avantages du tri par s√©lection** :\n- Nombre minimal d'√©changes (au plus n-1)\n- Simple √† comprendre et impl√©menter\n- Performant pour les petits tableaux\n\n---\n\n### Exercice 5 : Benchmark Complet des Algorithmes\n\n**Objectif** : Cr√©er un benchmark complet comparant tous les algorithmes de tri.\n\n**Consignes** :\n- Impl√©menter tous les algorithmes de tri vus dans ce chapitre\n- Cr√©er une fonction de benchmark qui mesure temps et nombre d'op√©rations\n- Tester avec diff√©rents types de donn√©es (al√©atoire, tri√©, inverse)\n\n```javascript\n// Structure attendue\nconst benchmarkResults = {\n    bubble: { time: 0, comparisons: 0, swaps: 0 },\n    insertion: { time: 0, comparisons: 0, swaps: 0 },\n    selection: { time: 0, comparisons: 0, swaps: 0 },\n    quick: { time: 0, comparisons: 0, swaps: 0 },\n    merge: { time: 0, comparisons: 0, swaps: 0 }\n};\n\nfunction runBenchmark() {\n    // TODO: impl√©menter le benchmark complet\n    // Retourner les r√©sultats comparatifs\n}\n```\n\n### Solution :\n```javascript\n// Compteurs globaux pour mesurer les op√©rations\nlet comparisons = 0;\nlet swaps = 0;\n\n// Fonction utilitaire pour mesurer le temps\nfunction measureTime(fn, arr) {\n    comparisons = 0;\n    swaps = 0;\n\n    const start = performance.now();\n    const result = fn([...arr]); // Copie pour ne pas modifier l'original\n    const end = performance.now();\n\n    return {\n        time: end - start,\n        comparisons: comparisons,\n        swaps: swaps,\n        result: result\n    };\n}\n\n// Tri √† bulles avec compteurs\nfunction bubbleSort(arr) {\n    for (let i = 0; i < arr.length - 1; i++) {\n        for (let j = 0; j < arr.length - i - 1; j++) {\n            comparisons++;\n            if (arr[j] > arr[j + 1]) {\n                swaps++;\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    return arr;\n}\n\n// Tri par insertion avec compteurs\nfunction insertionSort(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        let key = arr[i];\n        let j = i - 1;\n\n        while (j >= 0 && arr[j] > key) {\n            comparisons++;\n            arr[j + 1] = arr[j];\n            swaps++;\n            j--;\n        }\n        comparisons++; // Pour la derni√®re comparaison qui √©choue\n        arr[j + 1] = key;\n    }\n    return arr;\n}\n\n// Fonction principale de benchmark\nfunction runBenchmark() {\n    // G√©n√©ration de diff√©rents types de donn√©es de test\n    const sizes = [100, 500, 1000];\n    const dataTypes = {\n        random: (size) => Array.from({length: size}, () => Math.floor(Math.random() * 1000)),\n        sorted: (size) => Array.from({length: size}, (_, i) => i),\n        reverse: (size) => Array.from({length: size}, (_, i) => size - i),\n        nearlySorted: (size) => {\n            const arr = Array.from({length: size}, (_, i) => i);\n            // √âchanger quelques √©l√©ments\n            for (let i = 0; i < Math.floor(size * 0.1); i++) {\n                const idx1 = Math.floor(Math.random() * size);\n                const idx2 = Math.floor(Math.random() * size);\n                [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];\n            }\n            return arr;\n        }\n    };\n\n    const algorithms = {\n        bubble: bubbleSort,\n        insertion: insertionSort\n        // Ajouter les autres algorithmes...\n    };\n\n    const results = {};\n\n    console.log(\"üèÉ Lancement du benchmark complet...\\n\");\n\n    for (const [dataType, generator] of Object.entries(dataTypes)) {\n        console.log(`üìä Test avec donn√©es ${dataType}:`);\n        results[dataType] = {};\n\n        for (const size of sizes) {\n            const testData = generator(size);\n            console.log(`  Taille ${size}:`);\n\n            for (const [algoName, algoFn] of Object.entries(algorithms)) {\n                const metrics = measureTime(algoFn, testData);\n                results[dataType][size] = results[dataType][size] || {};\n                results[dataType][size][algoName] = metrics;\n\n                console.log(`    ${algoName}: ${metrics.time.toFixed(2)}ms, ${metrics.comparisons} comp, ${metrics.swaps} swaps`);\n            }\n        }\n        console.log(\"\");\n    }\n\n    return results;\n}\n\n// Ex√©cution du benchmark\nconst benchmarkResults = runBenchmark();\nconsole.log(\"Benchmark termin√© ! R√©sultats disponibles dans benchmarkResults\");\n```\n\n---\n\n## üìù Quiz de R√©vision\n\n### Question 1\nQuelle est la complexit√© temporelle moyenne du tri rapide ?\n- A) O(n)\n- B) O(n log n)  ‚Üê **R√©ponse**\n- C) O(n¬≤)\n- D) O(2‚Åø)\n\n### Question 2\nQuel algorithme de tri est consid√©r√© comme stable ?\n- A) Tri rapide\n- B) Tri fusion  ‚Üê **R√©ponse**\n- C) Tri rapide seulement\n- D) Aucun des trois\n\n### Question 3\nPour quel type de donn√©es le tri par comptage est-il particuli√®rement efficace ?\n- A) Cha√Ænes de caract√®res\n- B) Nombres avec une petite plage de valeurs  ‚Üê **R√©ponse**\n- C) Objets complexes\n- D) Donn√©es non comparables\n\n### Question 4\nQuelle op√©ration sur un tableau JavaScript est en O(1) ?\n- A) push()  ‚Üê **R√©ponse**\n- B) splice() au milieu\n- C) sort()\n- D) indexOf()\n\n---\n\n## üîë Points Cl√©s √† Retenir\n\n1. **Tableaux** = structures de donn√©es ordonn√©es avec acc√®s O(1) par index\n2. **Tri insertion** = simple, efficace sur petits tableaux ou presque tri√©s\n3. **Tri rapide** = g√©n√©ralement le plus rapide en pratique, O(n log n) moyen\n4. **Tri fusion** = stable, O(n log n) garanti, utilise O(n) espace\n5. **Tri bulle** = simple √† comprendre, mais O(n¬≤) - √† √©viter en production\n6. **Choisir l'algorithme** selon les contraintes (stabilit√©, m√©moire, donn√©es)\n\n---\n\n*Chapitre suivant : [Listes Cha√Æn√©es](03-linked-lists.md)*\n",
  "03": "# Chapitre 3 : Listes Cha√Æn√©es\n\n## üîó Qu'est-ce qu'une Liste Cha√Æn√©e ?\n\nUne **liste cha√Æn√©e** est une structure de donn√©es dynamique o√π chaque √©l√©ment (n≈ìud) contient :\n- **Donn√©es** : la valeur stock√©e\n- **R√©f√©rence** : pointeur vers l'√©l√©ment suivant (ou pr√©c√©dent)\n\nüí° **Analogie** : Comme des wagons de train connect√©s. Chaque wagon transporte des passagers et est accroch√© au suivant.\n\n### Avantages vs Tableaux\n\n| Aspect | Tableau | Liste Cha√Æn√©e |\n|--------|---------|---------------|\n| **Acc√®s** | O(1) par index | O(n) - parcours s√©quentiel |\n| **Insertion/D√©letion** | O(n) au milieu | O(1) si position connue |\n| **Taille** | Fixe (statique) | Dynamique |\n| **M√©moire** | Contigu√´ | √âparpill√©e |\n\n---\n\n## üìã Liste Simplement Cha√Æn√©e\n\n### Structure d'un N≈ìud\n\n```javascript\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n```\n\n### Impl√©mentation Compl√®te\n\n```javascript\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.size = 0;\n  }\n\n  // Ajouter au d√©but\n  prepend(value) {\n    const newNode = new Node(value);\n    newNode.next = this.head;\n    this.head = newNode;\n    this.size++;\n  }\n\n  // Ajouter √† la fin\n  append(value) {\n    const newNode = new Node(value);\n\n    if (!this.head) {\n      this.head = newNode;\n    } else {\n      let current = this.head;\n      while (current.next) {\n        current = current.next;\n      }\n      current.next = newNode;\n    }\n    this.size++;\n  }\n\n  // Ins√©rer √† une position donn√©e\n  insertAt(value, index) {\n    if (index < 0 || index > this.size) return false;\n\n    const newNode = new Node(value);\n\n    if (index === 0) {\n      this.prepend(value);\n      return true;\n    }\n\n    let current = this.head;\n    let previous = null;\n    let i = 0;\n\n    while (i < index) {\n      previous = current;\n      current = current.next;\n      i++;\n    }\n\n    previous.next = newNode;\n    newNode.next = current;\n    this.size++;\n    return true;\n  }\n\n  // Supprimer du d√©but\n  removeFirst() {\n    if (!this.head) return null;\n\n    const removedValue = this.head.value;\n    this.head = this.head.next;\n    this.size--;\n    return removedValue;\n  }\n\n  // Supprimer de la fin\n  removeLast() {\n    if (!this.head) return null;\n\n    if (!this.head.next) {\n      const removedValue = this.head.value;\n      this.head = null;\n      this.size--;\n      return removedValue;\n    }\n\n    let current = this.head;\n    let previous = null;\n\n    while (current.next) {\n      previous = current;\n      current = current.next;\n    }\n\n    previous.next = null;\n    this.size--;\n    return current.value;\n  }\n\n  // Supprimer √† une position\n  removeAt(index) {\n    if (index < 0 || index >= this.size) return null;\n\n    if (index === 0) return this.removeFirst();\n\n    let current = this.head;\n    let previous = null;\n    let i = 0;\n\n    while (i < index) {\n      previous = current;\n      current = current.next;\n      i++;\n    }\n\n    previous.next = current.next;\n    this.size--;\n    return current.value;\n  }\n\n  // Obtenir la valeur √† un index\n  get(index) {\n    if (index < 0 || index >= this.size) return null;\n\n    let current = this.head;\n    let i = 0;\n\n    while (i < index) {\n      current = current.next;\n      i++;\n    }\n\n    return current.value;\n  }\n\n  // Modifier la valeur √† un index\n  set(value, index) {\n    if (index < 0 || index >= this.size) return false;\n\n    let current = this.head;\n    let i = 0;\n\n    while (i < index) {\n      current = current.next;\n      i++;\n    }\n\n    current.value = value;\n    return true;\n  }\n\n  // V√©rifier si vide\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  // Obtenir la taille\n  getSize() {\n    return this.size;\n  }\n\n  // Afficher la liste\n  print() {\n    let current = this.head;\n    const values = [];\n\n    while (current) {\n      values.push(current.value);\n      current = current.next;\n    }\n\n    console.log(values.join(' -> '));\n  }\n\n  // Inverser la liste\n  reverse() {\n    let previous = null;\n    let current = this.head;\n    let next = null;\n\n    while (current) {\n      next = current.next;      // Sauvegarder le suivant\n      current.next = previous;  // Inverser le pointeur\n      previous = current;       // Avancer previous\n      current = next;           // Avancer current\n    }\n\n    this.head = previous;\n  }\n\n  // Trouver la valeur m√©diane\n  findMiddle() {\n    if (!this.head) return null;\n\n    let slow = this.head;\n    let fast = this.head;\n\n    while (fast && fast.next) {\n      slow = slow.next;\n      fast = fast.next.next;\n    }\n\n    return slow.value;\n  }\n\n  // D√©tecter un cycle (algorithme de Floyd)\n  hasCycle() {\n    if (!this.head) return false;\n\n    let slow = this.head;\n    let fast = this.head;\n\n    while (fast && fast.next) {\n      slow = slow.next;\n      fast = fast.next.next;\n\n      if (slow === fast) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n\n// Exemple d'utilisation\nconst list = new LinkedList();\n\nlist.append(10);\nlist.append(20);\nlist.append(30);\nlist.print(); // 10 -> 20 -> 30\n\nlist.prepend(5);\nlist.print(); // 5 -> 10 -> 20 -> 30\n\nlist.insertAt(15, 2);\nlist.print(); // 5 -> 10 -> 15 -> 20 -> 30\n\nconsole.log(list.get(2)); // 15\nconsole.log(list.findMiddle()); // 15 (milieu de 5 √©l√©ments)\n\nlist.reverse();\nlist.print(); // 30 -> 20 -> 15 -> 10 -> 5\n```\n\n---\n\n## üîÑ Liste Doublement Cha√Æn√©e\n\n### Structure d'un N≈ìud\n\n```javascript\nclass DoublyNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n    this.prev = null;\n  }\n}\n```\n\n### Impl√©mentation Compl√®te\n\n```javascript\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.size = 0;\n  }\n\n  // Ajouter au d√©but\n  prepend(value) {\n    const newNode = new DoublyNode(value);\n\n    if (!this.head) {\n      this.head = this.tail = newNode;\n    } else {\n      newNode.next = this.head;\n      this.head.prev = newNode;\n      this.head = newNode;\n    }\n    this.size++;\n  }\n\n  // Ajouter √† la fin\n  append(value) {\n    const newNode = new DoublyNode(value);\n\n    if (!this.tail) {\n      this.head = this.tail = newNode;\n    } else {\n      newNode.prev = this.tail;\n      this.tail.next = newNode;\n      this.tail = newNode;\n    }\n    this.size++;\n  }\n\n  // Supprimer du d√©but\n  removeFirst() {\n    if (!this.head) return null;\n\n    const removedValue = this.head.value;\n\n    if (this.head === this.tail) {\n      this.head = this.tail = null;\n    } else {\n      this.head = this.head.next;\n      this.head.prev = null;\n    }\n\n    this.size--;\n    return removedValue;\n  }\n\n  // Supprimer de la fin\n  removeLast() {\n    if (!this.tail) return null;\n\n    const removedValue = this.tail.value;\n\n    if (this.head === this.tail) {\n      this.head = this.tail = null;\n    } else {\n      this.tail = this.tail.prev;\n      this.tail.next = null;\n    }\n\n    this.size--;\n    return removedValue;\n  }\n\n  // Parcours inverse\n  printReverse() {\n    let current = this.tail;\n    const values = [];\n\n    while (current) {\n      values.push(current.value);\n      current = current.prev;\n    }\n\n    console.log(values.join(' <- '));\n  }\n\n  // Autres m√©thodes similaires √† la liste simplement cha√Æn√©e...\n}\n```\n\n---\n\n## üíª Exercices Pratiques\n\n### Exercice 1 : Fusion de Deux Listes Tri√©es\n\n**Objectif** : Fusionner deux listes cha√Æn√©es tri√©es en une seule liste tri√©e.\n\n```javascript\nfunction mergeSortedLists(list1, list2) {\n  const merged = new LinkedList();\n  let current1 = list1.head;\n  let current2 = list2.head;\n\n  while (current1 && current2) {\n    if (current1.value <= current2.value) {\n      merged.append(current1.value);\n      current1 = current1.next;\n    } else {\n      merged.append(current2.value);\n      current2 = current2.next;\n    }\n  }\n\n  // Ajouter les √©l√©ments restants\n  while (current1) {\n    merged.append(current1.value);\n    current1 = current1.next;\n  }\n\n  while (current2) {\n    merged.append(current2.value);\n    current2 = current2.next;\n  }\n\n  return merged;\n}\n\n// Test\nconst list1 = new LinkedList();\nlist1.append(1);\nlist1.append(3);\nlist1.append(5);\n\nconst list2 = new LinkedList();\nlist2.append(2);\nlist2.append(4);\nlist2.append(6);\n\nconst merged = mergeSortedLists(list1, list2);\nmerged.print(); // 1 -> 2 -> 3 -> 4 -> 5 -> 6\n```\n\n### Exercice 2 : Suppression des Doublons\n\n**Objectif** : Supprimer les √©l√©ments dupliqu√©s d'une liste cha√Æn√©e non tri√©e.\n\n```javascript\nfunction removeDuplicates(list) {\n  if (!list.head) return;\n\n  const seen = new Set();\n  let current = list.head;\n  let previous = null;\n\n  while (current) {\n    if (seen.has(current.value)) {\n      // Supprimer le n≈ìud\n      previous.next = current.next;\n      list.size--;\n    } else {\n      seen.add(current.value);\n      previous = current;\n    }\n    current = current.next;\n  }\n}\n\n// Test\nconst list = new LinkedList();\nlist.append(1);\nlist.append(2);\nlist.append(2);\nlist.append(3);\nlist.append(1);\n\nremoveDuplicates(list);\nlist.print(); // 1 -> 2 -> 3\n```\n\n### Exercice 3 : Point d'Intersection de Deux Listes\n\n**Objectif** : Trouver le n≈ìud d'intersection de deux listes cha√Æn√©es (si elles se croisent).\n\n```javascript\nfunction getIntersectionNode(list1, list2) {\n  if (!list1.head || !list2.head) return null;\n\n  // Calculer les longueurs\n  let len1 = 0, len2 = 0;\n  let current1 = list1.head, current2 = list2.head;\n\n  while (current1) { len1++; current1 = current1.next; }\n  while (current2) { len2++; current2 = current2.next; }\n\n  // Aligner les t√™tes\n  current1 = list1.head;\n  current2 = list2.head;\n\n  if (len1 > len2) {\n    for (let i = 0; i < len1 - len2; i++) {\n      current1 = current1.next;\n    }\n  } else {\n    for (let i = 0; i < len2 - len1; i++) {\n      current2 = current2.next;\n    }\n  }\n\n  // Chercher l'intersection\n  while (current1 && current2) {\n    if (current1 === current2) {\n      return current1;\n    }\n    current1 = current1.next;\n    current2 = current2.next;\n  }\n\n  return null;\n}\n```\n\n---\n\n## üìä Analyse de Complexit√©\n\n| Op√©ration | Liste Simplement Cha√Æn√©e | Liste Doublement Cha√Æn√©e |\n|-----------|--------------------------|--------------------------|\n| **Acc√®s par index** | O(n) | O(n) |\n| **Insertion d√©but** | O(1) | O(1) |\n| **Insertion fin** | O(n) | O(1) |\n| **Insertion milieu** | O(n) | O(n) |\n| **Suppression d√©but** | O(1) | O(1) |\n| **Suppression fin** | O(n) | O(1) |\n| **Recherche** | O(n) | O(n) |\n| **M√©moire** | O(n) | O(n) |\n\n---\n\n## üåü Cas d'Usage R√©els\n\n### 1. Gestion de la M√©moire (Allocation Dynamique)\n\n```javascript\nclass MemoryManager {\n  constructor() {\n    this.freeBlocks = new LinkedList(); // Blocs libres\n    this.allocatedBlocks = new LinkedList(); // Blocs allou√©s\n  }\n\n  allocate(size) {\n    // Chercher un bloc libre assez grand\n    let current = this.freeBlocks.head;\n    while (current) {\n      if (current.value.size >= size) {\n        // Allouer ce bloc\n        this.freeBlocks.removeAt(/* index du bloc */);\n        this.allocatedBlocks.append(current.value);\n        return current.value;\n      }\n      current = current.next;\n    }\n    return null; // Pas de bloc disponible\n  }\n\n  deallocate(block) {\n    // Lib√©rer le bloc\n    this.allocatedBlocks.removeAt(/* index */);\n    this.freeBlocks.append(block);\n  }\n}\n```\n\n### 2. Cache LRU (Least Recently Used)\n\n```javascript\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map(); // Pour acc√®s O(1)\n    this.order = new DoublyLinkedList(); // Pour ordre d'utilisation\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) return -1;\n\n    // D√©placer vers le d√©but (r√©cemment utilis√©)\n    const node = this.cache.get(key);\n    this.order.removeNode(node);\n    this.order.prepend(node);\n\n    return node.value;\n  }\n\n  put(key, value) {\n    if (this.cache.has(key)) {\n      // Mettre √† jour et d√©placer\n      const node = this.cache.get(key);\n      node.value = value;\n      this.order.removeNode(node);\n      this.order.prepend(node);\n    } else {\n      // Ajouter nouveau\n      if (this.order.size >= this.capacity) {\n        // Supprimer le moins r√©cemment utilis√©\n        const lru = this.order.tail;\n        this.cache.delete(lru.key);\n        this.order.removeLast();\n      }\n\n      const newNode = { key, value };\n      this.order.prepend(newNode);\n      this.cache.set(key, newNode);\n    }\n  }\n}\n```\n\n### 3. Annuler/R√©tablir (Undo/Redo)\n\n```javascript\nclass TextEditor {\n  constructor() {\n    this.text = \"\";\n    this.undoStack = new LinkedList(); // Actions √† annuler\n    this.redoStack = new LinkedList(); // Actions √† r√©tablir\n  }\n\n  type(text) {\n    this.undoStack.append({ action: 'type', text: this.text });\n    this.text += text;\n    this.redoStack = new LinkedList(); // Vider redo\n  }\n\n  undo() {\n    if (this.undoStack.isEmpty()) return;\n\n    const lastAction = this.undoStack.removeLast();\n    this.redoStack.append({ action: 'undo', text: this.text });\n    this.text = lastAction.text;\n  }\n\n  redo() {\n    if (this.redoStack.isEmpty()) return;\n\n    const lastRedo = this.redoStack.removeLast();\n    this.undoStack.append({ action: 'redo', text: this.text });\n    this.text = lastRedo.text;\n  }\n}\n```\n\n---\n\n## üîÑ Comparaison avec Autres Structures\n\n### Liste Cha√Æn√©e vs Tableau Dynamique\n\n| Aspect | Liste Cha√Æn√©e | ArrayList/Vector |\n|--------|---------------|------------------|\n| **Acc√®s al√©atoire** | ‚ùå O(n) | ‚úÖ O(1) |\n| **Insertion/D√©letion** | ‚úÖ O(1) si position connue | ‚ùå O(n) |\n| **M√©moire** | ‚ùå Overhead (pointeurs) | ‚úÖ Compact |\n| **Cache CPU** | ‚ùå Pas contigu | ‚úÖ Bon |\n| **Taille dynamique** | ‚úÖ Facile | ‚úÖ (avec redimensionnement) |\n\n### Quand Utiliser une Liste Cha√Æn√©e ?\n\n- **Insertions/D√©letions fr√©quentes** au milieu\n- **Taille inconnue** au d√©part\n- **Pas besoin d'acc√®s al√©atoire**\n- **Impl√©mentation de piles/files** (sans redimensionnement)\n\n---\n\n## üìù Quiz de R√©vision\n\n### Question 1\nQuelle est la complexit√© temporelle pour acc√©der au n-i√®me √©l√©ment d'une liste cha√Æn√©e ?\n- A) O(1)\n- B) O(log n)\n- C) O(n)  ‚Üê **R√©ponse**\n- D) O(n¬≤)\n\n### Question 2\nQuel est l'avantage principal d'une liste doublement cha√Æn√©e par rapport √† une liste simplement cha√Æn√©e ?\n- A) Moins de m√©moire utilis√©e\n- B) Parcours dans les deux sens en O(1)  ‚Üê **R√©ponse**\n- C) Recherche plus rapide\n- D) Insertion plus rapide\n\n### Question 3\nQuelle op√©ration est plus efficace sur une liste cha√Æn√©e que sur un tableau ?\n- A) Acc√®s par index\n- B) Insertion au d√©but  ‚Üê **R√©ponse**\n- C) Recherche d'un √©l√©ment\n- D) Tri\n\n### Question 4\nQuel algorithme permet de d√©tecter un cycle dans une liste cha√Æn√©e ?\n- A) Tri rapide\n- B) Recherche binaire\n- C) Algorithme des deux pointeurs (tortue/li√®vre)  ‚Üê **R√©ponse**\n- D) Tri fusion\n\n---\n\n## üîë Points Cl√©s √† Retenir\n\n1. **Liste cha√Æn√©e** = structure dynamique avec n≈ìuds connect√©s\n2. **Simplement cha√Æn√©e** = next seulement, **doublement** = next + prev\n3. **Complexit√©** : O(1) insertion/d√©letion connue, O(n) acc√®s al√©atoire\n4. **Avantages** : taille dynamique, insertions efficaces\n5. **Inconv√©nients** : pas d'acc√®s direct, overhead m√©moire\n6. **Applications** : piles, files, caches, gestion m√©moire\n\n---\n\n*Chapitre suivant : [R√©cursion & Diviser pour R√©gner](04-recursion-divide-conquer.md)*\n",
  "04": "# Chapitre 4 : R√©cursion & Diviser pour R√©gner\n\n## üîÑ La R√©cursion\n\n### D√©finition\n\nLa **r√©cursion** est une technique o√π une fonction s'appelle elle-m√™me pour r√©soudre un probl√®me.\n\nüí° **Analogie** : Comme une poup√©e russe - chaque poup√©e contient une version plus petite d'elle-m√™me.\n\n### √âl√©ments Essentiels\n\n1. **Cas de base** : condition d'arr√™t pour √©viter la r√©cursion infinie\n2. **Cas r√©cursif** : appel √† soi-m√™me avec un probl√®me plus petit\n3. **Progression** : chaque appel doit se rapprocher du cas de base\n\n---\n\n## üìä Exemples de Base\n\n### Factorielle\n\n**D√©finition math√©matique** : `n! = n √ó (n-1) √ó ... √ó 1`\n\n```javascript\nfunction factorielle(n) {\n  // Cas de base\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n\n  // Cas r√©cursif\n  return n * factorielle(n - 1);\n}\n\nconsole.log(factorielle(5)); // 120 (5! = 5 √ó 4 √ó 3 √ó 2 √ó 1)\n```\n\n**Visualisation de l'ex√©cution** :\n```\nfactorielle(5)\n  ‚Ü≥ 5 √ó factorielle(4)\n      ‚Ü≥ 4 √ó factorielle(3)\n          ‚Ü≥ 3 √ó factorielle(2)\n              ‚Ü≥ 2 √ó factorielle(1)\n                  ‚Ü≥ 1\n              ‚Ü≥ 2 √ó 1 = 2\n          ‚Ü≥ 3 √ó 2 = 6\n      ‚Ü≥ 4 √ó 6 = 24\n  ‚Ü≥ 5 √ó 24 = 120\n```\n\n### Suite de Fibonacci\n\n**D√©finition** : `F(n) = F(n-1) + F(n-2)` avec `F(0) = 0, F(1) = 1`\n\n```javascript\nfunction fibonacci(n) {\n  // Cas de base\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n\n  // Cas r√©cursif\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nconsole.log(fibonacci(6)); // 8 (0, 1, 1, 2, 3, 5, 8)\n```\n\n‚ö†Ô∏è **Probl√®me** : Cette impl√©mentation est **exponentielle** O(2‚Åø) √† cause des recalculs !\n\n### Version Optimis√©e (M√©mo√Øsation)\n\n```javascript\nfunction fibonacciMemo(n, memo = {}) {\n  // V√©rifier si d√©j√† calcul√©\n  if (memo[n] !== undefined) {\n    return memo[n];\n  }\n\n  // Cas de base\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n\n  // Calcul r√©cursif avec m√©mo√Øsation\n  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);\n  return memo[n];\n}\n\nconsole.log(fibonacciMemo(50)); // Tr√®s rapide !\n```\n\n**Complexit√©** : O(n) temps, O(n) espace\n\n---\n\n## üß† Raisonnement R√©cursif\n\n### Comment D√©composer un Probl√®me\n\nPrenons **la somme d'un tableau** :\n\n**Approche it√©rative** :\n```javascript\nfunction sommeIterative(arr) {\n  let total = 0;\n  for (let nombre of arr) {\n    total += nombre;\n  }\n  return total;\n}\n```\n\n**Approche r√©cursive** :\n```javascript\nfunction sommeRecursive(arr) {\n  // Cas de base : tableau vide\n  if (arr.length === 0) {\n    return 0;\n  }\n\n  // Cas r√©cursif : premier √©l√©ment + somme du reste\n  return arr[0] + sommeRecursive(arr.slice(1));\n}\n\nconsole.log(sommeRecursive([1, 2, 3, 4])); // 10\n```\n\n### R√®gles pour Reconna√Ætre un Probl√®me R√©cursif\n\n1. **Sous-probl√®mes similaires** : Le probl√®me peut √™tre divis√© en versions plus petites du m√™me probl√®me\n2. **R√©duction progressive** : Chaque √©tape r√©duit la taille du probl√®me\n3. **Cas de base identifiable** : Il existe une solution √©vidente pour les petits cas\n\n---\n\n## ‚úÇÔ∏è Diviser pour R√©gner\n\n### Strat√©gie Fondamentale\n\n**Diviser pour r√©gner** consiste √† :\n1. **Diviser** : Casser le probl√®me en sous-probl√®mes ind√©pendants\n2. **R√©gner** : R√©soudre r√©cursivement les sous-probl√®mes\n3. **Combiner** : Fusionner les solutions des sous-probl√®mes\n\n### Recherche Binaire (Exemple Classique)\n\n```javascript\nfunction rechercheBinaireRecursive(arr, cible, gauche = 0, droite = arr.length - 1) {\n  // Cas de base : √©l√©ment non trouv√©\n  if (gauche > droite) {\n    return -1;\n  }\n\n  // Diviser : trouver le milieu\n  const milieu = Math.floor((gauche + droite) / 2);\n\n  // R√©gner : comparer avec l'√©l√©ment du milieu\n  if (arr[milieu] === cible) {\n    return milieu;\n  }\n\n  // Diviser plus : chercher dans la moiti√© appropri√©e\n  if (arr[milieu] > cible) {\n    return rechercheBinaireRecursive(arr, cible, gauche, milieu - 1);\n  } else {\n    return rechercheBinaireRecursive(arr, cible, milieu + 1, droite);\n  }\n}\n\nconst arr = [1, 3, 5, 7, 9, 11, 13, 15];\nconsole.log(rechercheBinaireRecursive(arr, 7)); // 3\n```\n\n**Complexit√©** : O(log n)\n\n### Tri Fusion (Merge Sort)\n\n```javascript\nfunction triFusion(arr) {\n  // Cas de base\n  if (arr.length <= 1) {\n    return arr;\n  }\n\n  // Diviser : couper en deux\n  const milieu = Math.floor(arr.length / 2);\n  const gauche = arr.slice(0, milieu);\n  const droite = arr.slice(milieu);\n\n  // R√©gner : trier r√©cursivement\n  const gaucheTrie = triFusion(gauche);\n  const droiteTrie = triFusion(droite);\n\n  // Combiner : fusionner les deux moiti√©s tri√©es\n  return fusion(gaucheTrie, droiteTrie);\n}\n\nfunction fusion(gauche, droite) {\n  const resultat = [];\n  let i = 0, j = 0;\n\n  // Fusionner en comparant les √©l√©ments\n  while (i < gauche.length && j < droite.length) {\n    if (gauche[i] <= droite[j]) {\n      resultat.push(gauche[i]);\n      i++;\n    } else {\n      resultat.push(droite[j]);\n      j++;\n    }\n  }\n\n  // Ajouter les √©l√©ments restants\n  return resultat.concat(gauche.slice(i)).concat(droite.slice(j));\n}\n\nconsole.log(triFusion([38, 27, 43, 3, 9, 82, 10]));\n// [3, 9, 10, 27, 38, 43, 82]\n```\n\n**Complexit√©** : O(n log n)\n\n### Tour de Hano√Ø (Probl√®me Classique)\n\n**R√®gles** :\n- 3 tours (d√©part, auxiliaire, arriv√©e)\n- D√©placer n disques du d√©part vers l'arriv√©e\n- Un disque plus petit ne peut pas √™tre pos√© sur un plus grand\n\n```javascript\nfunction tourHanoi(n, depart, auxiliaire, arrivee) {\n  // Cas de base\n  if (n === 1) {\n    console.log(`D√©placer disque 1 de ${depart} vers ${arrivee}`);\n    return;\n  }\n\n  // √âtape 1 : d√©placer n-1 disques vers l'auxiliaire\n  tourHanoi(n - 1, depart, arrivee, auxiliaire);\n\n  // √âtape 2 : d√©placer le plus grand disque vers l'arriv√©e\n  console.log(`D√©placer disque ${n} de ${depart} vers ${arrivee}`);\n\n  // √âtape 3 : d√©placer les n-1 disques de l'auxiliaire vers l'arriv√©e\n  tourHanoi(n - 1, auxiliaire, depart, arrivee);\n}\n\ntourHanoi(3, 'A', 'B', 'C');\n/*\nD√©placer disque 1 de A vers C\nD√©placer disque 2 de A vers B\nD√©placer disque 1 de C vers B\nD√©placer disque 3 de A vers C\nD√©placer disque 1 de B vers A\nD√©placer disque 2 de B vers C\nD√©placer disque 1 de A vers C\n*/\n```\n\n**Complexit√©** : O(2‚Åø) - exponentielle !\n\n---\n\n## üîÑ R√©cursion vs It√©ration\n\n### Quand Utiliser la R√©cursion ?\n\n‚úÖ **Avantages** :\n- Code plus concis et √©l√©gant\n- Mod√©lise naturellement certains probl√®mes (arborescences)\n- Utilise la pile d'appel automatiquement\n\n‚ùå **Inconv√©nients** :\n- Risque de d√©bordement de pile (stack overflow)\n- Moins efficace (overhead des appels de fonction)\n- Plus difficile √† d√©boguer\n\n### Transformation R√©cursion ‚Üí It√©ration\n\n**Exemple : Factorielle**\n\n```javascript\n// R√©cursif\nfunction factorielleRec(n) {\n  if (n <= 1) return 1;\n  return n * factorielleRec(n - 1);\n}\n\n// It√©ratif\nfunction factorielleIter(n) {\n  let resultat = 1;\n  for (let i = 2; i <= n; i++) {\n    resultat *= i;\n  }\n  return resultat;\n}\n```\n\n**Exemple : Fibonacci**\n\n```javascript\n// R√©cursif avec m√©mo√Øsation\nfunction fibonacciRec(n, memo = {}) {\n  if (memo[n] !== undefined) return memo[n];\n  if (n <= 1) return n;\n  return memo[n] = fibonacciRec(n - 1, memo) + fibonacciRec(n - 2, memo);\n}\n\n// It√©ratif\nfunction fibonacciIter(n) {\n  if (n <= 1) return n;\n\n  let precedent = 0;\n  let courant = 1;\n\n  for (let i = 2; i <= n; i++) {\n    const suivant = precedent + courant;\n    precedent = courant;\n    courant = suivant;\n  }\n\n  return courant;\n}\n```\n\n---\n\n## üíª Exercices Pratiques\n\n### Exercice 1 : Puissance R√©cursive\n\n**Objectif** : Calculer x^n de mani√®re r√©cursive.\n\n**Version na√Øve** : O(n)\n```javascript\nfunction puissance(x, n) {\n  if (n === 0) return 1;\n  return x * puissance(x, n - 1);\n}\n```\n\n**Version optimis√©e** : O(log n)\n```javascript\nfunction puissanceOptimisee(x, n) {\n  if (n === 0) return 1;\n  if (n === 1) return x;\n\n  const moitie = puissanceOptimisee(x, Math.floor(n / 2));\n\n  if (n % 2 === 0) {\n    return moitie * moitie;\n  } else {\n    return x * moitie * moitie;\n  }\n}\n\nconsole.log(puissanceOptimisee(2, 10)); // 1024\n```\n\n### Exercice 2 : Inverser une Cha√Æne\n\n```javascript\nfunction inverserChaine(chaine) {\n  // Cas de base\n  if (chaine.length <= 1) {\n    return chaine;\n  }\n\n  // Cas r√©cursif\n  return inverserChaine(chaine.slice(1)) + chaine[0];\n}\n\nconsole.log(inverserChaine(\"hello\")); // \"olleh\"\n```\n\n### Exercice 3 : Somme des Chiffres\n\n```javascript\nfunction sommeChiffres(n) {\n  // Cas de base\n  if (n === 0) {\n    return 0;\n  }\n\n  // Cas r√©cursif\n  return (n % 10) + sommeChiffres(Math.floor(n / 10));\n}\n\nconsole.log(sommeChiffres(12345)); // 15 (1+2+3+4+5)\n```\n\n### Exercice 4 : Palindrome R√©cursif\n\n```javascript\nfunction estPalindrome(chaine) {\n  // Cas de base\n  if (chaine.length <= 1) {\n    return true;\n  }\n\n  // V√©rifier les extr√©mit√©s\n  if (chaine[0] !== chaine[chaine.length - 1]) {\n    return false;\n  }\n\n  // Cas r√©cursif : v√©rifier le milieu\n  return estPalindrome(chaine.slice(1, -1));\n}\n\nconsole.log(estPalindrome(\"radar\")); // true\nconsole.log(estPalindrome(\"hello\")); // false\n```\n\n### Exercice 5 : Maximum dans un Tableau\n\n```javascript\nfunction maximumTableau(arr, index = 0, maxActuel = -Infinity) {\n  // Cas de base\n  if (index >= arr.length) {\n    return maxActuel;\n  }\n\n  // Cas r√©cursif\n  const nouveauMax = Math.max(maxActuel, arr[index]);\n  return maximumTableau(arr, index + 1, nouveauMax);\n}\n\nconsole.log(maximumTableau([3, 7, 2, 9, 1])); // 9\n```\n\n---\n\n## üîç Probl√®mes Avanc√©s\n\n### Probl√®me : G√©n√©ration de Sous-Ensembles\n\n**Objectif** : G√©n√©rer tous les sous-ensembles d'un ensemble.\n\n```javascript\nfunction sousEnsembles(arr, index = 0, courant = []) {\n  // Cas de base : tous les √©l√©ments trait√©s\n  if (index >= arr.length) {\n    console.log(courant);\n    return;\n  }\n\n  // Ne pas inclure l'√©l√©ment actuel\n  sousEnsembles(arr, index + 1, [...courant]);\n\n  // Inclure l'√©l√©ment actuel\n  sousEnsembles(arr, index + 1, [...courant, arr[index]]);\n}\n\nsousEnsembles([1, 2, 3]);\n/*\n[]\n[3]\n[2]\n[2, 3]\n[1]\n[1, 3]\n[1, 2]\n[1, 2, 3]\n*/\n```\n\n### Probl√®me : R√©solution de Labyrinthe\n\n```javascript\nfunction resoudreLabyrinthe(labyrinthe, depart, arrivee, chemin = []) {\n  const [x, y] = depart;\n\n  // Cas de base : arriv√©\n  if (x === arrivee[0] && y === arrivee[1]) {\n    return [chemin.concat([depart])];\n  }\n\n  // Marquer comme visit√©\n  labyrinthe[y][x] = 1;\n\n  const solutions = [];\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n  for (let [dx, dy] of directions) {\n    const nx = x + dx;\n    const ny = y + dy;\n\n    // V√©rifier les limites et si chemin libre\n    if (nx >= 0 && nx < labyrinthe[0].length &&\n        ny >= 0 && ny < labyrinthe.length &&\n        labyrinthe[ny][nx] === 0) {\n\n      const nouvellesSolutions = resoudreLabyrinthe(\n        labyrinthe,\n        [nx, ny],\n        arrivee,\n        chemin.concat([depart])\n      );\n\n      solutions.push(...nouvellesSolutions);\n    }\n  }\n\n  // Remettre √† 0 (backtracking)\n  labyrinthe[y][x] = 0;\n\n  return solutions;\n}\n\n// Labyrinthe : 0 = chemin libre, 1 = mur\nconst labyrinthe = [\n  [0, 1, 0, 0],\n  [0, 1, 0, 1],\n  [0, 0, 0, 1],\n  [1, 0, 0, 0]\n];\n\nconst solutions = resoudreLabyrinthe(labyrinthe, [0, 0], [3, 3]);\nconsole.log(`Nombre de solutions: ${solutions.length}`);\n```\n\n---\n\n## ‚ö†Ô∏è Pi√®ges et Erreurs Courantes\n\n### 1. Oubli du Cas de Base\n\n```javascript\n// ‚ùå ERREUR : r√©cursion infinie\nfunction factorielleInfinie(n) {\n  return n * factorielleInfinie(n - 1); // Pas de cas de base !\n}\n```\n\n### 2. Cas de Base Incorrect\n\n```javascript\n// ‚ùå ERREUR : factorielle(1) = 0 ?\nfunction factorielleErreur(n) {\n  if (n === 1) return 0; // Erreur !\n  return n * factorielleErreur(n - 1);\n}\n```\n\n### 3. Probl√®me de Performance\n\n```javascript\n// ‚ùå Fibonacci r√©cursif na√Øf = O(2‚Åø)\nfunction fibonacciLent(n) {\n  if (n <= 1) return n;\n  return fibonacciLent(n - 1) + fibonacciLent(n - 2);\n}\n```\n\n### 4. Variables Globales dans la R√©cursion\n\n```javascript\n// ‚ùå ERREUR : variable globale modifi√©e\nlet compteur = 0;\nfunction compter(n) {\n  compteur++; // Probl√®me si appels imbriqu√©s !\n  if (n <= 1) return n;\n  return compter(n - 1) + compter(n - 2);\n}\n```\n\n---\n\n## üìä Complexit√© des Algorithmes R√©cursifs\n\n| Algorithme | Complexit√© | Explication |\n|------------|------------|-------------|\n| **Factorielle** | O(n) | n appels r√©cursifs |\n| **Fibonacci (m√©mo√Øs√©)** | O(n) | Chaque valeur calcul√©e une fois |\n| **Fibonacci (na√Øf)** | O(2‚Åø) | Arbre d'appels exponentiel |\n| **Recherche binaire** | O(log n) | Division par 2 √† chaque √©tape |\n| **Tri fusion** | O(n log n) | Division + fusion lin√©aire |\n| **Tour de Hano√Ø** | O(2‚Åø) | Doublement des appels |\n\n---\n\n## üéØ Applications R√©elles\n\n### 1. Syst√®mes de Fichiers (Arborescences)\n\n```javascript\nfunction listerFichiers(dossier, profondeur = 0) {\n  const indentation = '  '.repeat(profondeur);\n\n  for (let element of dossier.contenu) {\n    console.log(`${indentation}${element.nom}`);\n\n    if (element.type === 'dossier') {\n      listerFichiers(element, profondeur + 1);\n    }\n  }\n}\n```\n\n### 2. √âvaluation d'Expressions Math√©matiques\n\n```javascript\nfunction evaluerExpression(expression) {\n  // Parser et √©valuer r√©cursivement\n  // Exemple simplifi√© pour illustration\n  if (typeof expression === 'number') {\n    return expression;\n  }\n\n  const [gauche, operateur, droite] = expression;\n\n  switch (operateur) {\n    case '+': return evaluerExpression(gauche) + evaluerExpression(droite);\n    case '-': return evaluerExpression(gauche) - evaluerExpression(droite);\n    case '*': return evaluerExpression(gauche) * evaluerExpression(droite);\n    case '/': return evaluerExpression(gauche) / evaluerExpression(droite);\n  }\n}\n```\n\n### 3. Algorithmes de Tri et Recherche\n\n- **Tri rapide** : partition r√©cursive\n- **Tri fusion** : division r√©cursive\n- **Recherche dans les arbres** : parcours r√©cursif\n\n---\n\n## üìù Quiz de R√©vision\n\n### Question 1\nQuel est l'√©l√©ment essentiel pour √©viter une r√©cursion infinie ?\n- A) Une boucle while\n- B) Un cas de base  ‚Üê **R√©ponse**\n- C) Une variable globale\n- D) Un param√®tre optionnel\n\n### Question 2\nQuelle est la complexit√© du tri fusion ?\n- A) O(n)\n- B) O(n log n)  ‚Üê **R√©ponse**\n- C) O(n¬≤)\n- D) O(2‚Åø)\n\n### Question 3\nQuelle strat√©gie algorithmique divise le probl√®me en sous-probl√®mes ind√©pendants ?\n- A) Programmation dynamique\n- B) Diviser pour r√©gner  ‚Üê **R√©ponse**\n- C) Algorithme glouton\n- D) Backtracking\n\n### Question 4\nPourquoi la r√©cursion peut-elle causer un stack overflow ?\n- A) M√©moire insuffisante\n- B) Trop d'appels r√©cursifs empil√©s  ‚Üê **R√©ponse**\n- C) Variables locales trop grandes\n- D) Calculs trop complexes\n\n---\n\n## üîë Points Cl√©s √† Retenir\n\n1. **R√©cursion** = fonction qui s'appelle elle-m√™me\n2. **Cas de base** = condition d'arr√™t obligatoire\n3. **Diviser pour r√©gner** = diviser, r√©gner, combiner\n4. **Complexit√©** : attention aux appels multiples (exponentielle)\n5. **M√©mo√Øsation** = optimisation pour √©viter les recalculs\n6. **R√©cursion vs It√©ration** : √©l√©gance vs performance\n\n---\n\n*Chapitre suivant : [Arbres Binaires de Recherche](08-binary-search-trees.md)*\n",
  "05": "# Chapitre 5 : Les Piles (Stacks)\n\n## ü•û Qu'est-ce qu'une Pile ?\n\nUne **pile** (stack) est une structure de donn√©es lin√©aire qui suit le principe :\n\nüëâ **LIFO** (Last In, First Out) : le dernier √©l√©ment ajout√© est le premier √† √™tre retir√©.\n\nüí° **Exemple concret** : une pile d'assiettes dans une cantine ‚Üí tu ajoutes toujours au-dessus, tu retires toujours au-dessus.\n\n### Sch√©ma Illustratif\n\n```\nHaut de la pile ‚Üí [üçé]\n                  [üçå]\n                  [üçê]  ‚Üê Base de la pile\n```\n\n- `push(üçé)` ‚Üí ajoute en haut\n- `pop()` ‚Üí retire üçé\n\n---\n\n## üîß Op√©rations Principales\n\n- **`push(x)`** ‚Üí ajoute un √©l√©ment en haut\n- **`pop()`** ‚Üí retire l'√©l√©ment du haut\n- **`peek()`** ‚Üí consulte l'√©l√©ment du haut sans le retirer\n- **`isEmpty()`** ‚Üí v√©rifie si la pile est vide\n\n---\n\n## üíª Impl√©mentation en JavaScript\n\n```javascript\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n\n  push(element) {\n    this.items.push(element);\n  }\n\n  pop() {\n    if (this.isEmpty()) return null;\n    return this.items.pop();\n  }\n\n  peek() {\n    return this.isEmpty() ? null : this.items[this.items.length - 1];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  size() {\n    return this.items.length;\n  }\n}\n\n// Exemple d'utilisation\nconst stack = new Stack();\nstack.push(\"üçé\");\nstack.push(\"üçå\");\nconsole.log(stack.peek()); // üçå\nconsole.log(stack.pop());  // üçå\nconsole.log(stack.pop());  // üçé\nconsole.log(stack.pop());  // null\n```\n\n### Impl√©mentation avec Objets (alternative)\n\n```javascript\nclass StackObj {\n  constructor() {\n    this.items = {};\n    this.count = 0;\n  }\n\n  push(element) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n\n  pop() {\n    if (this.isEmpty()) return null;\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n\n  peek() {\n    if (this.isEmpty()) return null;\n    return this.items[this.count - 1];\n  }\n\n  isEmpty() {\n    return this.count === 0;\n  }\n\n  size() {\n    return this.count;\n  }\n}\n```\n\n---\n\n## üåü Cas d'Usage R√©els\n\n### 1. Gestion des Annulations (Ctrl+Z)\n\n```javascript\nclass EditeurTexte {\n  constructor() {\n    this.texte = \"\";\n    this.historique = new Stack();\n  }\n\n  ecrire(texte) {\n    this.historique.push(this.texte);\n    this.texte += texte;\n  }\n\n  annuler() {\n    if (!this.historique.isEmpty()) {\n      this.texte = this.historique.pop();\n    }\n  }\n}\n\nconst editeur = new EditeurTexte();\nediteur.ecrire(\"Hello \");\nediteur.ecrire(\"World!\");\nconsole.log(editeur.texte); // \"Hello World!\"\nediteur.annuler();\nconsole.log(editeur.texte); // \"Hello \"\n```\n\n### 2. Parcours R√©cursif Transform√© en It√©ratif\n\n```javascript\n// Parcours en profondeur d'un arbre (DFS it√©ratif)\nfunction dfsIteratif(racine) {\n  const pile = new Stack();\n  pile.push(racine);\n\n  while (!pile.isEmpty()) {\n    const noeud = pile.pop();\n    console.log(noeud.valeur);\n\n    // Ajouter les enfants (du dernier au premier pour garder l'ordre)\n    if (noeud.droit) pile.push(noeud.droit);\n    if (noeud.gauche) pile.push(noeud.gauche);\n  }\n}\n```\n\n### 3. √âvaluation d'Expressions Arithm√©tiques\n\n```javascript\nfunction evaluerExpression(expression) {\n  const pile = new Stack();\n  const tokens = expression.split(' ');\n\n  for (let token of tokens) {\n    if (!isNaN(token)) {\n      pile.push(parseFloat(token));\n    } else {\n      const b = pile.pop();\n      const a = pile.pop();\n\n      switch(token) {\n        case '+': pile.push(a + b); break;\n        case '-': pile.push(a - b); break;\n        case '*': pile.push(a * b); break;\n        case '/': pile.push(a / b); break;\n      }\n    }\n  }\n\n  return pile.pop();\n}\n\nconsole.log(evaluerExpression(\"3 4 + 2 *\")); // (3 + 4) * 2 = 14\n```\n\n### 4. V√©rification de Parentheses\n\n```javascript\nfunction parenthesesEquilibrees(expression) {\n  const pile = new Stack();\n  const ouvrantes = '({[';\n  const fermantes = ')}]';\n\n  for (let char of expression) {\n    if (ouvrantes.includes(char)) {\n      pile.push(char);\n    } else if (fermantes.includes(char)) {\n      if (pile.isEmpty()) return false;\n\n      const ouvrante = pile.pop();\n      const indexOuvrante = ouvrantes.indexOf(ouvrante);\n      const indexFermante = fermantes.indexOf(char);\n\n      if (indexOuvrante !== indexFermante) return false;\n    }\n  }\n\n  return pile.isEmpty();\n}\n\nconsole.log(parenthesesEquilibrees(\"((2+3) * (5-1))\")); // true\nconsole.log(parenthesesEquilibrees(\"(2+3))(\")); // false\n```\n\n---\n\n## üíª Exercice Pratique 1\n\n**Objectif** : Impl√©mentez une fonction `isBalanced(expression)` qui v√©rifie si les parenth√®ses d'une expression sont bien √©quilibr√©es.\n\n**Exemples** :\n- `\"((2+3) * (5-1))\"` ‚Üí ‚úÖ √©quilibr√©\n- `\"(2+3))(\"` ‚Üí ‚ùå d√©s√©quilibr√©\n- `\"[{(2+3)*5}]\"` ‚Üí ‚úÖ √©quilibr√©\n\n### Solution :\n```javascript\nfunction isBalanced(expression) {\n  const pile = new Stack();\n  const paires = {\n    ')': '(',\n    '}': '{',\n    ']': '['\n  };\n\n  for (let char of expression) {\n    if (['(', '{', '['].includes(char)) {\n      pile.push(char);\n    } else if ([')', '}', ']'].includes(char)) {\n      if (pile.isEmpty() || pile.pop() !== paires[char]) {\n        return false;\n      }\n    }\n  }\n\n  return pile.isEmpty();\n}\n```\n\n---\n\n## üíª Exercice Pratique 2\n\n**Objectif** : Impl√©mentez une calculatrice RPN (Notation Polonaise Inverse).\n\n**Exemple** :\n- Expression : `\"3 4 + 5 *\"`\n- R√©sultat : `(3 + 4) * 5 = 35`\n\n### Solution :\n```javascript\nfunction calculatriceRPN(expression) {\n  const pile = new Stack();\n  const tokens = expression.split(' ');\n\n  for (let token of tokens) {\n    if (!isNaN(token)) {\n      pile.push(parseFloat(token));\n    } else {\n      const b = pile.pop();\n      const a = pile.pop();\n\n      switch(token) {\n        case '+': pile.push(a + b); break;\n        case '-': pile.push(a - b); break;\n        case '*': pile.push(a * b); break;\n        case '/': pile.push(a / b); break;\n        case '^': pile.push(Math.pow(a, b)); break;\n      }\n    }\n  }\n\n  return pile.pop();\n}\n\nconsole.log(calculatriceRPN(\"3 4 + 5 *\")); // 35\nconsole.log(calculatriceRPN(\"10 2 / 3 +\")); // 8 (10/2 + 3)\n```\n\n---\n\n## üíª Exercice Pratique 3\n\n**Objectif** : Impl√©mentez une fonction qui inverse une cha√Æne de caract√®res en utilisant une pile.\n\n**Exemple** :\n- `\"Hello World\"` ‚Üí `\"dlroW olleH\"`\n\n### Solution :\n```javascript\nfunction inverserChaine(chaine) {\n  const pile = new Stack();\n\n  // Empiler chaque caract√®re\n  for (let char of chaine) {\n    pile.push(char);\n  }\n\n  // D√©piler pour reconstruire\n  let resultat = '';\n  while (!pile.isEmpty()) {\n    resultat += pile.pop();\n  }\n\n  return resultat;\n}\n\nconsole.log(inverserChaine(\"Hello World\")); // \"dlroW olleH\"\n```\n\n---\n\n## üìä Analyse de Complexit√©\n\n| Op√©ration | Complexit√© |\n|-----------|------------|\n| `push()` | O(1) |\n| `pop()` | O(1) |\n| `peek()` | O(1) |\n| `isEmpty()` | O(1) |\n\n**Espace** : O(n) o√π n est le nombre d'√©l√©ments\n\n---\n\n## üìù Quiz de R√©vision\n\n### Question 1\nQuelle est la diff√©rence entre une pile et une file ?\n- A) La pile est LIFO, la file est FIFO  ‚Üê **R√©ponse**\n- B) La pile utilise plus de m√©moire\n- C) La file est plus rapide\n- D) Aucune diff√©rence\n\n### Question 2\nQuelle op√©ration permet de consulter le dernier √©l√©ment sans le retirer ?\n- A) `pop()`\n- B) `push()`\n- C) `peek()`  ‚Üê **R√©ponse**\n- D) `isEmpty()`\n\n### Question 3\nDonnez un exemple concret d'utilisation d'une pile dans un logiciel.\n- A) Imprimante\n- B) Annulation (Ctrl+Z)  ‚Üê **R√©ponse**\n- C) File d'attente de processus\n- D) Cache m√©moire\n\n### Question 4\nDans une pile vide, que retourne `pop()` dans notre impl√©mentation ?\n- A) `undefined`\n- B) Erreur\n- C) `null`  ‚Üê **R√©ponse**\n- D) `0`\n\n---\n\n## üîë Points Cl√©s √† Retenir\n\n1. **Pile** = structure LIFO (Last In, First Out)\n2. **Op√©rations principales** : `push()`, `pop()`, `peek()`, `isEmpty()`\n3. **Complexit√©** : toutes les op√©rations en O(1)\n4. **Applications** : annulations, r√©cursion it√©rative, v√©rification de parenth√®ses\n5. **Impl√©mentation** : facile avec un tableau JavaScript (`push()` et `pop()`)\n\n---\n\n*Chapitre suivant : [Les Files (Queues)](06-queues.md)*\n",
  "06": "# Chapitre 6 : Les Files (Queues)\n\n## üö∂ Qu'est-ce qu'une File ?\n\nUne **file** (queue) est une structure de donn√©es lin√©aire qui suit le principe :\n\nüëâ **FIFO** (First In, First Out) : le premier √©l√©ment entr√© est le premier √† sortir.\n\nüí° **Exemple concret** : une file d'attente au supermarch√© ‚Üí le premier client arriv√© est le premier servi.\n\n### Sch√©ma Illustratif\n\n```\nEntr√©e ‚Üí [üö∂] [üö∂] [üö∂] ‚Üí Sortie\n         Alice  Bob   Clara\n```\n\n- `enqueue(üö∂)` ‚Üí ajoute une personne √† la fin de la file\n- `dequeue()` ‚Üí retire la personne en t√™te de file\n\n---\n\n## üîß Op√©rations Principales\n\n- **`enqueue(x)`** ‚Üí ajoute un √©l√©ment √† la fin\n- **`dequeue()`** ‚Üí retire l'√©l√©ment au d√©but\n- **`peek()`** ‚Üí consulte le premier √©l√©ment sans le retirer\n- **`isEmpty()`** ‚Üí v√©rifie si la file est vide\n\n---\n\n## üíª Impl√©mentation en JavaScript\n\n```javascript\nclass Queue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element) {\n    this.items.push(element);\n  }\n\n  dequeue() {\n    if (this.isEmpty()) return null;\n    return this.items.shift(); // retire le premier √©l√©ment\n  }\n\n  peek() {\n    return this.isEmpty() ? null : this.items[0];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  size() {\n    return this.items.length;\n  }\n}\n\n// Exemple d'utilisation\nconst queue = new Queue();\nqueue.enqueue(\"Alice\");\nqueue.enqueue(\"Bob\");\nqueue.enqueue(\"Clara\");\n\nconsole.log(queue.dequeue()); // Alice\nconsole.log(queue.peek());    // Bob\nconsole.log(queue.dequeue()); // Bob\n```\n\n### Impl√©mentation Optimis√©e (avec deux pointeurs)\n\n```javascript\nclass QueueOptimisee {\n  constructor() {\n    this.items = {};\n    this.debut = 0;\n    this.fin = 0;\n  }\n\n  enqueue(element) {\n    this.items[this.fin] = element;\n    this.fin++;\n  }\n\n  dequeue() {\n    if (this.isEmpty()) return null;\n    const element = this.items[this.debut];\n    delete this.items[this.debut];\n    this.debut++;\n    return element;\n  }\n\n  peek() {\n    return this.isEmpty() ? null : this.items[this.debut];\n  }\n\n  isEmpty() {\n    return this.debut === this.fin;\n  }\n\n  size() {\n    return this.fin - this.debut;\n  }\n}\n```\n\n---\n\n## üåü Cas d'Usage R√©els\n\n### 1. Imprimante\n\n```javascript\nclass GestionImprimante {\n  constructor() {\n    this.fileImpression = new Queue();\n  }\n\n  ajouterDocument(document) {\n    this.fileImpression.enqueue(document);\n    console.log(`Document \"${document}\" ajout√© √† la file d'impression`);\n  }\n\n  imprimer() {\n    if (this.fileImpression.isEmpty()) {\n      console.log(\"Aucun document √† imprimer\");\n      return;\n    }\n\n    const document = this.fileImpression.dequeue();\n    console.log(`Impression de \"${document}\"...`);\n  }\n}\n\nconst imprimante = new GestionImprimante();\nimprimante.ajouterDocument(\"Rapport.pdf\");\nimprimante.ajouterDocument(\"CV.docx\");\nimprimante.imprimer(); // Imprime Rapport.pdf en premier\n```\n\n### 2. Syst√®mes d'Exploitation (Ordonnanceur de Processus)\n\n```javascript\nclass Ordonnanceur {\n  constructor() {\n    this.fileProcessus = new Queue();\n  }\n\n  ajouterProcessus(processus) {\n    this.fileProcessus.enqueue({\n      ...processus,\n      arrivee: Date.now()\n    });\n  }\n\n  executerProcessus() {\n    if (this.fileProcessus.isEmpty()) return;\n\n    const processus = this.fileProcessus.dequeue();\n    console.log(`Ex√©cution de ${processus.nom} (priorit√©: ${processus.priorite})`);\n\n    // Simulation d'ex√©cution\n    setTimeout(() => {\n      console.log(`${processus.nom} termin√©`);\n    }, processus.duree * 1000);\n  }\n}\n```\n\n### 3. Simulations de Files d'Attente\n\n```javascript\nclass SimulationSupermarche {\n  constructor() {\n    this.file = new Queue();\n    this.tempsTotal = 0;\n  }\n\n  arriver(client) {\n    this.file.enqueue({\n      nom: client,\n      arrivee: Date.now()\n    });\n  }\n\n  servir() {\n    if (this.file.isEmpty()) return null;\n\n    const client = this.file.dequeue();\n    const tempsAttente = Date.now() - client.arrivee;\n    this.tempsTotal += tempsAttente;\n\n    return {\n      client: client.nom,\n      tempsAttente: tempsAttente\n    };\n  }\n\n  moyenneTempsAttente() {\n    return this.tempsTotal / Math.max(1, this.file.size());\n  }\n}\n```\n\n### 4. Parcours en Largeur (BFS)\n\n```javascript\nfunction parcoursLargeur(graphe, depart) {\n  const file = new Queue();\n  const visites = new Set();\n\n  file.enqueue(depart);\n  visites.add(depart);\n\n  while (!file.isEmpty()) {\n    const sommet = file.dequeue();\n    console.log(sommet);\n\n    // Ajouter les voisins non visit√©s\n    for (let voisin of graphe[sommet] || []) {\n      if (!visites.has(voisin)) {\n        visites.add(voisin);\n        file.enqueue(voisin);\n      }\n    }\n  }\n}\n\n// Exemple\nconst reseau = {\n  'Alice': ['Bob', 'Charlie'],\n  'Bob': ['Alice', 'Diana'],\n  'Charlie': ['Alice', 'Diana'],\n  'Diana': ['Bob', 'Charlie']\n};\n\nparcoursLargeur(reseau, 'Alice'); // Alice, Bob, Charlie, Diana\n```\n\n---\n\n## üíª Exercice Pratique 1\n\n**Objectif** : Impl√©mentez une file et simulez une file d'attente au cin√©ma.\n\n**Consignes** :\n- 5 clients arrivent successivement dans la file\n- √Ä chaque √©tape, un client est servi (retir√© de la file)\n- Affichez l'√©tat de la file apr√®s chaque op√©ration\n\n```javascript\nclass Cinema {\n  constructor() {\n    this.file = new Queue();\n  }\n\n  arriver(client) {\n    this.file.enqueue(client);\n    this.afficherFile();\n  }\n\n  servir() {\n    const client = this.file.dequeue();\n    if (client) {\n      console.log(`üéüÔ∏è ${client} est servi`);\n      this.afficherFile();\n    }\n  }\n\n  afficherFile() {\n    console.log(`File actuelle: [${this.file.items.join(', ')}]`);\n  }\n}\n\nconst cinema = new Cinema();\ncinema.arriver(\"Alice\");\ncinema.arriver(\"Bob\");\ncinema.arriver(\"Charlie\");\ncinema.arriver(\"Diana\");\ncinema.arriver(\"Eve\");\n\ncinema.servir();\ncinema.servir();\n```\n\n---\n\n## üíª Exercice Pratique 2\n\n**Objectif** : Impl√©mentez une file avec priorit√©.\n\n**Consignes** :\n- Les √©l√©ments ont une priorit√© (nombre)\n- Les √©l√©ments de haute priorit√© sont servis en premier\n- Impl√©mentez `enqueue(element, priorite)` et `dequeue()`\n\n```javascript\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element, priorite) {\n    const item = { element, priorite };\n    let ajoute = false;\n\n    for (let i = 0; i < this.items.length; i++) {\n      if (priorite > this.items[i].priorite) {\n        this.items.splice(i, 0, item);\n        ajoute = true;\n        break;\n      }\n    }\n\n    if (!ajoute) {\n      this.items.push(item);\n    }\n  }\n\n  dequeue() {\n    return this.items.shift()?.element;\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n\n// Test\nconst pq = new PriorityQueue();\npq.enqueue(\"T√¢che normale\", 1);\npq.enqueue(\"Urgence\", 5);\npq.enqueue(\"Importante\", 3);\n\nconsole.log(pq.dequeue()); // \"Urgence\"\nconsole.log(pq.dequeue()); // \"Importante\"\nconsole.log(pq.dequeue()); // \"T√¢che normale\"\n```\n\n---\n\n## üíª Exercice Pratique 3\n\n**Objectif** : R√©soudre le probl√®me des producteurs-consommateurs.\n\n**Sc√©nario** : Plusieurs producteurs ajoutent des t√¢ches, un consommateur les traite.\n\n```javascript\nclass TacheSysteme {\n  constructor() {\n    this.fileTaches = new Queue();\n    this.enCours = false;\n  }\n\n  ajouterTache(tache) {\n    this.fileTaches.enqueue(tache);\n    console.log(`üìã T√¢che ajout√©e: ${tache}`);\n    this.traiterSiPossible();\n  }\n\n  traiterSiPossible() {\n    if (!this.enCours && !this.fileTaches.isEmpty()) {\n      this.enCours = true;\n      const tache = this.fileTaches.dequeue();\n      console.log(`‚öôÔ∏è Traitement de: ${tache}`);\n\n      // Simulation de traitement asynchrone\n      setTimeout(() => {\n        console.log(`‚úÖ ${tache} termin√©e`);\n        this.enCours = false;\n        this.traiterSiPossible(); // Traiter la suivante\n      }, Math.random() * 2000 + 1000);\n    }\n  }\n}\n\nconst systeme = new TacheSysteme();\nsysteme.ajouterTache(\"Sauvegarde donn√©es\");\nsysteme.ajouterTache(\"Mise √† jour antivirus\");\nsysteme.ajouterTache(\"Nettoyage disque\");\n```\n\n---\n\n## üìä Analyse de Complexit√©\n\n| Op√©ration | Complexit√© (Tableau) | Complexit√© (Optimis√©e) |\n|-----------|---------------------|----------------------|\n| `enqueue()` | O(1) | O(1) |\n| `dequeue()` | O(n) - √† cause de `shift()` | O(1) |\n| `peek()` | O(1) | O(1) |\n| `isEmpty()` | O(1) | O(1) |\n\n**Espace** : O(n) dans les deux cas\n\n‚ö†Ô∏è **Note** : L'impl√©mentation avec tableau natif a un `dequeue()` en O(n) √† cause du `shift()`. L'impl√©mentation optimis√©e r√©sout ce probl√®me.\n\n---\n\n## üìù Quiz de R√©vision\n\n### Question 1\nQuelle est la diff√©rence entre une pile et une file ?\n- A) La pile est LIFO, la file est FIFO  ‚Üê **R√©ponse**\n- B) La file utilise plus de m√©moire\n- C) La pile est plus rapide\n- D) Aucune diff√©rence\n\n### Question 2\nQuelle m√©thode permet de retirer le premier √©l√©ment ?\n- A) `enqueue()`\n- B) `dequeue()`  ‚Üê **R√©ponse**\n- C) `peek()`\n- D) `push()`\n\n### Question 3\nCite un exemple d'utilisation d'une file dans un syst√®me informatique.\n- A) Annulation (Ctrl+Z)\n- B) V√©rification de parenth√®ses\n- C) Impression de documents  ‚Üê **R√©ponse**\n- D) Calculatrice RPN\n\n### Question 4\nDans l'impl√©mentation avec tableau, quelle op√©ration est co√ªteuse ?\n- A) `enqueue()` (O(1))\n- B) `dequeue()` (O(n))  ‚Üê **R√©ponse**\n- C) `peek()` (O(1))\n- D) `isEmpty()` (O(1))\n\n---\n\n## üîë Points Cl√©s √† Retenir\n\n1. **File** = structure FIFO (First In, First Out)\n2. **Op√©rations principales** : `enqueue()`, `dequeue()`, `peek()`, `isEmpty()`\n3. **Complexit√©** : `enqueue()` et `peek()` en O(1), `dequeue()` en O(n) avec tableau\n4. **Applications** : impression, ordonnancement, simulations, BFS\n5. **Optimisation** : utiliser des pointeurs pour √©viter le co√ªt du `shift()`\n\n---\n\n*Chapitre suivant : [R√©cursion & Diviser pour R√©gner](04-recursion-divide-conquer.md)*\n",
  "07": "# Chapitre 7 : Les Tables de Hachage (Hash Tables)\n\n## üîë Qu'est-ce qu'une Table de Hachage ?\n\nUne **table de hachage** est une structure de donn√©es qui associe des cl√©s √† des valeurs.\n\nüëâ Elle permet des op√©rations rapides (insertion, recherche, suppression) en moyenne en **O(1)**.\n\nüí° **Exemple concret** :\n- Un dictionnaire ‚Üí mot = cl√©, d√©finition = valeur\n- Un carnet de contacts ‚Üí nom = cl√©, num√©ro = valeur\n\n### Sch√©ma Illustratif\n\n```\nFonction de hachage : \"chat\" ‚Üí hash ‚Üí case m√©moire 5\n\nTable de hachage :\n[0] ‚Üí ...\n[1] ‚Üí ...\n[2] ‚Üí ...\n[3] ‚Üí ...\n[4] ‚Üí ...\n[5] ‚Üí \"chat\" : \"üê±\"\n[6] ‚Üí ...\n```\n\n---\n\n## üîß Les Op√©rations Principales\n\n- **`set(key, value)`** ‚Üí ins√©rer une paire cl√©/valeur\n- **`get(key)`** ‚Üí retrouver la valeur associ√©e √† la cl√©\n- **`remove(key)`** ‚Üí supprimer la paire\n- **`has(key)`** ‚Üí v√©rifier si une cl√© existe\n\n---\n\n## üî¢ Fonction de Hachage\n\n### D√©finition\n\nUne **fonction de hachage** transforme une cl√© en un indice de tableau.\n\n**Propri√©t√©s importantes** :\n- **D√©terministe** : m√™me cl√© ‚Üí m√™me hash\n- **Rapide** : calcul en O(1)\n- **Uniforme** : distribution homog√®ne des valeurs\n\n### Exemples de Fonctions de Hachage\n\n```javascript\n// Hachage simple pour cha√Ænes\nfunction hashSimple(cle, tailleTable) {\n  let hash = 0;\n  for (let char of cle) {\n    hash += char.charCodeAt(0);\n  }\n  return hash % tailleTable;\n}\n\nconsole.log(hashSimple(\"chat\", 10)); // 5\nconsole.log(hashSimple(\"chien\", 10)); // 8\n\n// Hachage DJB2 (plus robuste)\nfunction hashDJB2(cle, tailleTable) {\n  let hash = 5381;\n  for (let char of cle) {\n    hash = ((hash << 5) + hash) + char.charCodeAt(0);\n  }\n  return Math.abs(hash) % tailleTable;\n}\n\nconsole.log(hashDJB2(\"chat\", 10)); // 7\nconsole.log(hashDJB2(\"chien\", 10)); // 3\n```\n\n---\n\n## üí• Gestion des Collisions\n\n**Probl√®me** : deux cl√©s diff√©rentes peuvent produire le m√™me hash.\n\n### 1. Cha√Ænage (Chaining)\n\nChaque case contient une liste d'√©l√©ments.\n\n```javascript\nclass HashTableChaining {\n  constructor(size = 10) {\n    this.table = new Array(size);\n    this.size = size;\n  }\n\n  _hash(key) {\n    let hash = 0;\n    for (let char of key) {\n      hash += char.charCodeAt(0);\n    }\n    return hash % this.size;\n  }\n\n  set(key, value) {\n    const index = this._hash(key);\n    if (!this.table[index]) {\n      this.table[index] = [];\n    }\n\n    // V√©rifier si la cl√© existe d√©j√†\n    for (let i = 0; i < this.table[index].length; i++) {\n      if (this.table[index][i][0] === key) {\n        this.table[index][i][1] = value;\n        return;\n      }\n    }\n\n    this.table[index].push([key, value]);\n  }\n\n  get(key) {\n    const index = this._hash(key);\n    const bucket = this.table[index];\n    if (bucket) {\n      for (let [k, v] of bucket) {\n        if (k === key) return v;\n      }\n    }\n    return undefined;\n  }\n\n  remove(key) {\n    const index = this._hash(key);\n    const bucket = this.table[index];\n    if (bucket) {\n      for (let i = 0; i < bucket.length; i++) {\n        if (bucket[i][0] === key) {\n          bucket.splice(i, 1);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  has(key) {\n    return this.get(key) !== undefined;\n  }\n}\n\n// Exemple d'utilisation\nconst ht = new HashTableChaining();\nht.set(\"chat\", \"üê±\");\nht.set(\"chien\", \"üê∂\");\nconsole.log(ht.get(\"chat\"));  // üê±\nconsole.log(ht.get(\"chien\")); // üê∂\n\n// Collision simul√©e\nht.set(\"tac\", \"collision!\"); // M√™me hash que \"chat\" probablement\nconsole.log(ht.get(\"tac\"));   // collision!\n```\n\n### 2. Adressage Ouvert (Open Addressing)\n\nSi une case est occup√©e, chercher la suivante disponible.\n\n**Techniques** :\n- **Lin√©aire** : case suivante (index + 1)\n- **Quadratique** : case + 1¬≤, + 2¬≤, + 3¬≤...\n- **Double hachage** : utiliser une deuxi√®me fonction de hachage\n\n```javascript\nclass HashTableOpenAddressing {\n  constructor(size = 10) {\n    this.table = new Array(size).fill(null);\n    this.size = size;\n  }\n\n  _hash(key) {\n    let hash = 0;\n    for (let char of key) {\n      hash += char.charCodeAt(0);\n    }\n    return hash % this.size;\n  }\n\n  set(key, value) {\n    let index = this._hash(key);\n    let originalIndex = index;\n\n    while (this.table[index] !== null && this.table[index][0] !== key) {\n      index = (index + 1) % this.size;\n\n      // Si on a fait le tour complet\n      if (index === originalIndex) {\n        throw new Error(\"Table pleine\");\n      }\n    }\n\n    this.table[index] = [key, value];\n  }\n\n  get(key) {\n    let index = this._hash(key);\n    let originalIndex = index;\n\n    while (this.table[index] !== null) {\n      if (this.table[index][0] === key) {\n        return this.table[index][1];\n      }\n      index = (index + 1) % this.size;\n\n      if (index === originalIndex) break;\n    }\n\n    return undefined;\n  }\n\n  remove(key) {\n    let index = this._hash(key);\n    let originalIndex = index;\n\n    while (this.table[index] !== null) {\n      if (this.table[index][0] === key) {\n        this.table[index] = null;\n        return true;\n      }\n      index = (index + 1) % this.size;\n\n      if (index === originalIndex) break;\n    }\n\n    return false;\n  }\n}\n```\n\n---\n\n## üíª Impl√©mentation Moderne (ES6 Map)\n\n```javascript\n// JavaScript fournit une impl√©mentation native\nconst map = new Map();\n\nmap.set(\"chat\", \"üê±\");\nmap.set(\"chien\", \"üê∂\");\n\nconsole.log(map.get(\"chat\"));  // üê±\nconsole.log(map.has(\"oiseau\")); // false\nconsole.log(map.size);         // 2\n\n// It√©ration\nfor (let [cle, valeur] of map) {\n  console.log(`${cle} -> ${valeur}`);\n}\n```\n\n---\n\n## üåü Cas d'Usage R√©els\n\n### 1. Dictionnaires (Objets JavaScript)\n\n```javascript\n// Un objet JS est essentiellement une table de hachage\nconst dictionnaire = {\n  \"chat\": \"üê±\",\n  \"chien\": \"üê∂\",\n  \"oiseau\": \"üê¶\"\n};\n\nconsole.log(dictionnaire[\"chat\"]); // üê±\n```\n\n### 2. Cache M√©moire\n\n```javascript\nclass Cache {\n  constructor(capacity = 100) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n\n  get(key) {\n    if (this.cache.has(key)) {\n      // Remettre au d√©but (LRU)\n      const value = this.cache.get(key);\n      this.cache.delete(key);\n      this.cache.set(key, value);\n      return value;\n    }\n    return null;\n  }\n\n  set(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.capacity) {\n      // Supprimer le moins r√©cemment utilis√©\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n\n    this.cache.set(key, value);\n  }\n}\n```\n\n### 3. Comptage d'Occurrences\n\n```javascript\nfunction compterMots(texte) {\n  const mots = texte.toLowerCase().split(/\\s+/);\n  const compteur = new Map();\n\n  for (let mot of mots) {\n    mot = mot.replace(/[.,!?]/g, ''); // Nettoyer\n    if (mot) {\n      compteur.set(mot, (compteur.get(mot) || 0) + 1);\n    }\n  }\n\n  return compteur;\n}\n\nconst resultat = compterMots(\"Le chat chasse le chat.\");\nconsole.log(resultat); // Map { 'le' => 2, 'chat' => 2, 'chasse' => 1 }\n```\n\n### 4. Recherche Rapide dans un Ensemble\n\n```javascript\nclass EnsembleRapide {\n  constructor() {\n    this.items = new Set(); // Set utilise une table de hachage\n  }\n\n  ajouter(element) {\n    this.items.add(element);\n  }\n\n  contient(element) {\n    return this.items.has(element);\n  }\n\n  supprimer(element) {\n    return this.items.delete(element);\n  }\n}\n```\n\n---\n\n## üíª Exercice Pratique 1\n\n**Objectif** : Impl√©mentez une fonction `countWords(text)` qui utilise une table de hachage pour compter combien de fois chaque mot appara√Æt dans une phrase.\n\n**Exemple** :\n```\ncountWords(\"chat chien chat oiseau\")\n// R√©sultat attendu : { chat: 2, chien: 1, oiseau: 1 }\n```\n\n### Solution :\n```javascript\nfunction countWords(text) {\n  const words = text.toLowerCase().split(/\\s+/);\n  const count = new Map();\n\n  for (let word of words) {\n    // Nettoyer le mot\n    word = word.replace(/[.,!?;:]/g, '');\n    if (word) {\n      count.set(word, (count.get(word) || 0) + 1);\n    }\n  }\n\n  return Object.fromEntries(count);\n}\n\nconsole.log(countWords(\"Le chat noir chasse le chat blanc.\"));\n// { le: 2, chat: 2, noir: 1, chasse: 1, blanc: 1 }\n```\n\n---\n\n## üíª Exercice Pratique 2\n\n**Objectif** : Impl√©mentez un cache LRU (Least Recently Used) simple.\n\n**Consignes** :\n- Capacit√© maximale\n- Quand plein, supprimer l'√©l√©ment le moins r√©cemment utilis√©\n- `get()` et `set()` doivent mettre √† jour l'ordre d'utilisation\n\n### Solution :\n```javascript\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map(); // Cl√© -> Valeur, ordre pr√©serv√©\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) return -1;\n\n    const value = this.cache.get(key);\n    this.cache.delete(key); // Supprimer\n    this.cache.set(key, value); // Remettre √† la fin\n    return value;\n  }\n\n  put(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.capacity) {\n      // Supprimer le premier (moins r√©cemment utilis√©)\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n\n    this.cache.set(key, value);\n  }\n}\n\n// Test\nconst cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\nconsole.log(cache.get(1)); // 1 (remis au d√©but)\ncache.put(3, 3); // 2 sera supprim√© (LRU)\nconsole.log(cache.get(2)); // -1 (supprim√©)\n```\n\n---\n\n### Exercice 3 : Table de Hachage Personnalis√©e\n\n**Objectif** : Impl√©menter une table de hachage compl√®te avec cha√Ænage.\n\n**Consignes** :\n- Impl√©menter une classe `HashTable` avec les m√©thodes de base\n- Utiliser le cha√Ænage pour g√©rer les collisions\n- Inclure les op√©rations CRUD (Create, Read, Update, Delete)\n\n```javascript\nclass HashTable {\n    constructor(size = 53) {\n        // TODO: impl√©menter le constructeur\n    }\n\n    // Fonction de hachage simple\n    _hash(key) {\n        // TODO: impl√©menter\n    }\n\n    set(key, value) {\n        // TODO: impl√©menter\n    }\n\n    get(key) {\n        // TODO: impl√©menter\n    }\n\n    remove(key) {\n        // TODO: impl√©menter\n    }\n\n    has(key) {\n        // TODO: impl√©menter\n    }\n\n    keys() {\n        // TODO: retourner toutes les cl√©s\n    }\n\n    values() {\n        // TODO: retourner toutes les valeurs\n    }\n\n    clear() {\n        // TODO: vider la table\n    }\n}\n\n// Tests\nconst ht = new HashTable();\nht.set(\"nom\", \"Alice\");\nht.set(\"age\", 25);\nht.set(\"ville\", \"Paris\");\n\nconsole.log(ht.get(\"nom\")); // \"Alice\"\nconsole.log(ht.has(\"age\")); // true\nht.remove(\"ville\");\nconsole.log(ht.has(\"ville\")); // false\n```\n\n### Solution :\n```javascript\nclass HashTable {\n    constructor(size = 53) {\n        this.keyMap = new Array(size);\n    }\n\n    _hash(key) {\n        let total = 0;\n        const WEIRD_PRIME = 31;\n\n        for (let i = 0; i < Math.min(key.length, 100); i++) {\n            const char = key[i];\n            const value = char.charCodeAt(0) - 96;\n            total = (total * WEIRD_PRIME + value) % this.keyMap.length;\n        }\n\n        return total;\n    }\n\n    set(key, value) {\n        const index = this._hash(key);\n\n        if (!this.keyMap[index]) {\n            this.keyMap[index] = [];\n        }\n\n        // V√©rifier si la cl√© existe d√©j√†\n        for (let i = 0; i < this.keyMap[index].length; i++) {\n            if (this.keyMap[index][i][0] === key) {\n                this.keyMap[index][i][1] = value;\n                return;\n            }\n        }\n\n        this.keyMap[index].push([key, value]);\n    }\n\n    get(key) {\n        const index = this._hash(key);\n\n        if (this.keyMap[index]) {\n            for (let i = 0; i < this.keyMap[index].length; i++) {\n                if (this.keyMap[index][i][0] === key) {\n                    return this.keyMap[index][i][1];\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    remove(key) {\n        const index = this._hash(key);\n\n        if (this.keyMap[index]) {\n            for (let i = 0; i < this.keyMap[index].length; i++) {\n                if (this.keyMap[index][i][0] === key) {\n                    this.keyMap[index].splice(i, 1);\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    has(key) {\n        return this.get(key) !== undefined;\n    }\n\n    keys() {\n        const keysArr = [];\n\n        for (let i = 0; i < this.keyMap.length; i++) {\n            if (this.keyMap[i]) {\n                for (let j = 0; j < this.keyMap[i].length; j++) {\n                    keysArr.push(this.keyMap[i][j][0]);\n                }\n            }\n        }\n\n        return keysArr;\n    }\n\n    values() {\n        const valuesArr = [];\n\n        for (let i = 0; i < this.keyMap.length; i++) {\n            if (this.keyMap[i]) {\n                for (let j = 0; j < this.keyMap[i].length; j++) {\n                    valuesArr.push(this.keyMap[i][j][1]);\n                }\n            }\n        }\n\n        return valuesArr;\n    }\n\n    clear() {\n        this.keyMap = new Array(this.keyMap.length);\n    }\n}\n```\n\n---\n\n### Exercice 4 : Analyse des Collisions\n\n**Objectif** : Analyser l'impact des collisions sur les performances.\n\n**Consignes** :\n- Cr√©er une fonction qui mesure le taux de collisions\n- Tester diff√©rentes fonctions de hachage\n- √âtudier l'impact de la taille de la table\n\n```javascript\nfunction analyserCollisions(hashFunction, keys, tableSize) {\n    // TODO: impl√©menter l'analyse des collisions\n    // Retourner des m√©triques sur les collisions\n}\n\n// Fonctions de hachage √† tester\nfunction hashSimple(key, size) {\n    let total = 0;\n    for (let char of key) {\n        total += char.charCodeAt(0);\n    }\n    return total % size;\n}\n\nfunction hashDJB2(key, size) {\n    let hash = 5381;\n    for (let char of key) {\n        hash = ((hash << 5) + hash) + char.charCodeAt(0);\n    }\n    return Math.abs(hash) % size;\n}\n\n// Test\nconst mots = [\"chat\", \"chien\", \"oiseau\", \"poisson\", \"lapin\", \"hamster\", \"perroquet\"];\n\nconsole.log(\"Analyse avec hashSimple:\");\nconsole.log(analyserCollisions(hashSimple, mots, 10));\n\nconsole.log(\"Analyse avec hashDJB2:\");\nconsole.log(analyserCollisions(hashDJB2, mots, 10));\n```\n\n### Solution :\n```javascript\nfunction analyserCollisions(hashFunction, keys, tableSize) {\n    const distribution = new Array(tableSize).fill(0);\n    const collisions = new Array(tableSize).fill(0);\n\n    // Calculer la distribution des hashes\n    for (let key of keys) {\n        const hash = hashFunction(key, tableSize);\n        distribution[hash]++;\n\n        if (distribution[hash] > 1) {\n            collisions[hash] = distribution[hash] - 1;\n        }\n    }\n\n    // Calculer les m√©triques\n    const totalCollisions = collisions.reduce((sum, count) => sum + count, 0);\n    const maxCollisions = Math.max(...collisions);\n    const avgCollisions = totalCollisions / keys.length;\n    const loadFactor = keys.length / tableSize;\n\n    // Cases vides\n    const emptySlots = distribution.filter(count => count === 0).length;\n\n    return {\n        totalCollisions,\n        maxCollisions,\n        avgCollisions,\n        loadFactor,\n        emptySlots,\n        distribution,\n        collisions\n    };\n}\n\n// Fonction d'affichage des r√©sultats\nfunction afficherAnalyse(resultats, nomFonction) {\n    console.log(`üìä Analyse pour ${nomFonction}:`);\n    console.log(`   Total des collisions: ${resultats.totalCollisions}`);\n    console.log(`   Maximum de collisions par case: ${resultats.maxCollisions}`);\n    console.log(`   Moyenne de collisions: ${resultats.avgCollisions.toFixed(2)}`);\n    console.log(`   Facteur de charge: ${resultats.loadFactor.toFixed(2)}`);\n    console.log(`   Cases vides: ${resultats.emptySlots}`);\n    console.log(`   Distribution: [${resultats.distribution.join(', ')}]`);\n    console.log(\"\");\n}\n\n// Test √©tendu\nconst mots = [\"chat\", \"chien\", \"oiseau\", \"poisson\", \"lapin\", \"hamster\", \"perroquet\"];\n\nconsole.log(\"üîç Analyse comparative des fonctions de hachage\\n\");\n\nconst resultatsSimple = analyserCollisions(hashSimple, mots, 10);\nafficherAnalyse(resultatsSimple, \"hashSimple\");\n\nconst resultatsDJB2 = analyserCollisions(hashDJB2, mots, 10);\nafficherAnalyse(resultatsDJB2, \"hashDJB2\");\n\n// Test avec diff√©rentes tailles de table\nconsole.log(\"üìè Impact de la taille de la table:\");\nconst tailles = [5, 10, 20, 50];\n\nfor (let taille of tailles) {\n    const resultats = analyserCollisions(hashDJB2, mots, taille);\n    console.log(`   Taille ${taille}: ${resultats.totalCollisions} collisions, facteur ${resultats.loadFactor.toFixed(2)}`);\n}\n```\n\n---\n\n### Exercice 5 : Cache Multi-Niveau\n\n**Objectif** : Impl√©menter un syst√®me de cache multi-niveau utilisant des tables de hachage.\n\n**Consignes** :\n- Cache L1 : petit, rapide (Map)\n- Cache L2 : plus grand, plus lent (HashTable personnalis√©e)\n- Strat√©gie de remplacement LRU\n- Mesurer les performances\n\n```javascript\nclass MultiLevelCache {\n    constructor(l1Size = 10, l2Size = 100) {\n        // TODO: impl√©menter le cache multi-niveau\n    }\n\n    get(key) {\n        // TODO: v√©rifier L1 d'abord, puis L2\n    }\n\n    set(key, value) {\n        // TODO: strat√©gie de placement\n    }\n\n    // Statistiques\n    getStats() {\n        // TODO: retourner les m√©triques de performance\n    }\n}\n\n// Simulation d'utilisation\nconst cache = new MultiLevelCache(5, 20);\n\n// Simulation de requ√™tes\nconst requests = ['A', 'B', 'A', 'C', 'B', 'D', 'A', 'E', 'F', 'A'];\n\nfor (let req of requests) {\n    cache.get(req) || cache.set(req, `valeur-${req}`);\n}\n\nconsole.log(cache.getStats());\n```\n\n### Solution :\n```javascript\nclass MultiLevelCache {\n    constructor(l1Size = 10, l2Size = 100) {\n        this.l1 = new Map(); // Cache L1 : rapide\n        this.l2 = new Map(); // Cache L2 : plus grand\n        this.l1Size = l1Size;\n        this.l2Size = l2Size;\n\n        // Statistiques\n        this.stats = {\n            l1Hits: 0,\n            l2Hits: 0,\n            misses: 0,\n            totalRequests: 0\n        };\n\n        // Pour LRU, on utilise un ordre d'acc√®s\n        this.l1Order = [];\n        this.l2Order = [];\n    }\n\n    get(key) {\n        this.stats.totalRequests++;\n\n        // V√©rifier L1 d'abord\n        if (this.l1.has(key)) {\n            this.stats.l1Hits++;\n            this.updateOrder(this.l1Order, key);\n            return this.l1.get(key);\n        }\n\n        // V√©rifier L2\n        if (this.l2.has(key)) {\n            this.stats.l2Hits++;\n            this.updateOrder(this.l2Order, key);\n\n            // Promouvoir vers L1\n            const value = this.l2.get(key);\n            this.set(key, value);\n            return value;\n        }\n\n        // Cache miss\n        this.stats.misses++;\n        return null;\n    }\n\n    set(key, value) {\n        // Si d√©j√† dans L1, mettre √† jour\n        if (this.l1.has(key)) {\n            this.l1.set(key, value);\n            this.updateOrder(this.l1Order, key);\n            return;\n        }\n\n        // Ajouter √† L1\n        if (this.l1.size >= this.l1Size) {\n            // √âvincer le moins r√©cemment utilis√© de L1\n            const lruKey = this.l1Order.shift();\n            const lruValue = this.l1.get(lruKey);\n\n            // D√©placer vers L2 si L2 n'est pas plein\n            if (this.l2.size < this.l2Size) {\n                this.l2.set(lruKey, lruValue);\n                this.l2Order.push(lruKey);\n            }\n\n            this.l1.delete(lruKey);\n        }\n\n        this.l1.set(key, value);\n        this.l1Order.push(key);\n    }\n\n    updateOrder(orderArray, key) {\n        // Retirer la cl√© existante et la remettre √† la fin\n        const index = orderArray.indexOf(key);\n        if (index > -1) {\n            orderArray.splice(index, 1);\n        }\n        orderArray.push(key);\n    }\n\n    getStats() {\n        const l1HitRate = this.stats.l1Hits / this.stats.totalRequests;\n        const l2HitRate = this.stats.l2Hits / this.stats.totalRequests;\n        const totalHitRate = (this.stats.l1Hits + this.stats.l2Hits) / this.stats.totalRequests;\n\n        return {\n            totalRequests: this.stats.totalRequests,\n            l1Hits: this.stats.l1Hits,\n            l2Hits: this.stats.l2Hits,\n            misses: this.stats.misses,\n            l1HitRate: l1HitRate.toFixed(3),\n            l2HitRate: l2HitRate.toFixed(3),\n            totalHitRate: totalHitRate.toFixed(3),\n            l1Size: this.l1.size,\n            l2Size: this.l2.size\n        };\n    }\n}\n\n// Test du cache multi-niveau\nconst cache = new MultiLevelCache(3, 10);\n\n// Simulation de requ√™tes avec localit√© temporelle\nconst requests = [\n    'A', 'B', 'C', // Remplit L1\n    'A', 'B',      // Hits L1\n    'D', 'E', 'F', // Ajoute √† L1, √©vince vers L2\n    'A', 'D',      // A en L1, D promu de L2 vers L1\n    'G', 'H', 'I', 'J', 'K' // Continue...\n];\n\nconsole.log(\"üîÑ Simulation du cache multi-niveau:\");\nconsole.log(\"Requ√™tes:\", requests.join(' ‚Üí '));\nconsole.log(\"\");\n\nfor (let i = 0; i < requests.length; i++) {\n    const req = requests[i];\n    const result = cache.get(req);\n\n    if (!result) {\n        // Cache miss - d√©finir une valeur\n        cache.set(req, `data-${req}`);\n        console.log(`${i + 1}. ${req}: MISS ‚Üí ajout√© au cache`);\n    } else {\n        console.log(`${i + 1}. ${req}: HIT ‚Üí ${result}`);\n    }\n}\n\nconsole.log(\"\");\nconsole.log(\"üìä Statistiques finales:\");\nconst stats = cache.getStats();\nconsole.log(`   Requ√™tes totales: ${stats.totalRequests}`);\nconsole.log(`   Hits L1: ${stats.l1Hits} (${stats.l1HitRate})`);\nconsole.log(`   Hits L2: ${stats.l2Hits} (${stats.l2HitRate})`);\nconsole.log(`   Misses: ${stats.misses}`);\nconsole.log(`   Taux de succ√®s total: ${stats.totalHitRate}`);\nconsole.log(`   Taille L1: ${stats.l1Size}, L2: ${stats.l2Size}`);\n```\n\n---\n\n## üìä Analyse de Complexit√©\n\n| Op√©ration | Moyenne | Pire Cas |\n|-----------|---------|----------|\n| `set()` | O(1) | O(n) - collisions |\n| `get()` | O(1) | O(n) - collisions |\n| `remove()` | O(1) | O(n) - collisions |\n\n**Facteurs influen√ßant les performances** :\n- Qualit√© de la fonction de hachage\n- Taux de remplissage (load factor)\n- Strat√©gie de gestion des collisions\n\n---\n\n## üìù Quiz de R√©vision\n\n### Question 1\nQuel est l'avantage principal d'une table de hachage par rapport √† un tableau ?\n- A) Tri automatique\n- B) Recherche en O(1) moyenne  ‚Üê **R√©ponse**\n- C) M√©moire r√©duite\n- D) Stabilit√© garantie\n\n### Question 2\nQue se passe-t-il si deux cl√©s produisent le m√™me hash ?\n- A) Erreur\n- B) Collision, √† g√©rer  ‚Üê **R√©ponse**\n- C) Valeur √©cras√©e\n- D) Recherche impossible\n\n### Question 3\nQuelle m√©thode de gestion des collisions utilise des listes cha√Æn√©es ?\n- A) Adressage ouvert\n- B) Cha√Ænage  ‚Üê **R√©ponse**\n- C) Double hachage\n- D) Re-hachage\n\n### Question 4\nDans quelle structure JavaScript retrouve-t-on une table de hachage ?\n- A) Array\n- B) Map  ‚Üê **R√©ponse**\n- C) Set\n- D) String\n\n---\n\n## üîë Points Cl√©s √† Retenir\n\n1. **Table de hachage** = association cl√©-valeur avec recherche O(1) moyenne\n2. **Fonction de hachage** = transforme cl√© en indice, doit √™tre rapide et uniforme\n3. **Collisions** = in√©vitables, g√©r√©es par cha√Ænage ou adressage ouvert\n4. **Applications** : caches, dictionnaires, comptage, ensembles rapides\n5. **JavaScript** : `Map` et `Set` utilisent des tables de hachage\n6. **Performance** : d√©pend de la fonction de hachage et du taux de remplissage\n\n---\n\n*Chapitre suivant : [Arbres Binaires de Recherche](08-binary-search-trees.md)*\n",
  "08": "# Chapitre 8 : Arbres Binaires de Recherche (BST)\n\n## üå≥ Qu'est-ce qu'un Arbre Binaire de Recherche ?\n\nUn **arbre binaire de recherche** (BST) est une structure de donn√©es arborescente o√π chaque n≈ìud respecte une propri√©t√© d'ordre.\n\n### Propri√©t√© Fondamentale\n\nPour chaque n≈ìud :\n- **Sous-arbre gauche** : valeurs ‚â§ valeur du n≈ìud\n- **Sous-arbre droit** : valeurs > valeur du n≈ìud\n\n### Structure d'un N≈ìud\n\n```javascript\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.left = null;   // Sous-arbre gauche\n    this.right = null;  // Sous-arbre droit\n  }\n}\n```\n\n---\n\n## üå≤ Impl√©mentation Compl√®te d'un BST\n\n```javascript\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n\n  // Insertion d'une valeur\n  insert(value) {\n    const newNode = new Node(value);\n\n    if (!this.root) {\n      this.root = newNode;\n      return this;\n    }\n\n    let current = this.root;\n\n    while (true) {\n      if (value === current.value) {\n        return this; // Valeurs dupliqu√©es non autoris√©es\n      }\n\n      if (value < current.value) {\n        if (!current.left) {\n          current.left = newNode;\n          return this;\n        }\n        current = current.left;\n      } else {\n        if (!current.right) {\n          current.right = newNode;\n          return this;\n        }\n        current = current.right;\n      }\n    }\n  }\n\n  // Recherche d'une valeur\n  find(value) {\n    let current = this.root;\n\n    while (current) {\n      if (value === current.value) {\n        return current;\n      }\n\n      if (value < current.value) {\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n    }\n\n    return null;\n  }\n\n  // V√©rification de l'existence\n  contains(value) {\n    return this.find(value) !== null;\n  }\n\n  // Suppression d'une valeur\n  remove(value) {\n    this.root = this.removeNode(this.root, value);\n    return this;\n  }\n\n  removeNode(node, value) {\n    if (!node) return null;\n\n    if (value < node.value) {\n      node.left = this.removeNode(node.left, value);\n      return node;\n    } else if (value > node.value) {\n      node.right = this.removeNode(node.right, value);\n      return node;\n    } else {\n      // N≈ìud trouv√© - 3 cas possibles\n\n      // Cas 1 : Feuille (pas d'enfants)\n      if (!node.left && !node.right) {\n        return null;\n      }\n\n      // Cas 2 : Un seul enfant\n      if (!node.left) return node.right;\n      if (!node.right) return node.left;\n\n      // Cas 3 : Deux enfants - trouver le successeur\n      const successor = this.findMin(node.right);\n      node.value = successor.value;\n      node.right = this.removeNode(node.right, successor.value);\n      return node;\n    }\n  }\n\n  findMin(node = this.root) {\n    while (node && node.left) {\n      node = node.left;\n    }\n    return node;\n  }\n\n  findMax(node = this.root) {\n    while (node && node.right) {\n      node = node.right;\n    }\n    return node;\n  }\n}\n\n// Exemple d'utilisation\nconst bst = new BinarySearchTree();\nbst.insert(10);\nbst.insert(5);\nbst.insert(15);\nbst.insert(3);\nbst.insert(7);\nbst.insert(13);\nbst.insert(17);\n\nconsole.log(bst.contains(7));  // true\nconsole.log(bst.contains(12)); // false\n\nbst.remove(5); // Supprimer n≈ìud avec deux enfants\n```\n\n---\n\n## üîç Parcours d'un Arbre Binaire\n\n### 1. Parcours en Ordre (In-Order)\n\n**Ordre** : Gauche ‚Üí Racine ‚Üí Droite  \n**R√©sultat** : Valeurs tri√©es !\n\n```javascript\nfunction inOrderTraversal(node, result = []) {\n  if (node) {\n    inOrderTraversal(node.left, result);\n    result.push(node.value);\n    inOrderTraversal(node.right, result);\n  }\n  return result;\n}\n\n// Exemple\nconst bst = new BinarySearchTree();\n[10, 5, 15, 3, 7, 13, 17].forEach(val => bst.insert(val));\n\nconsole.log(inOrderTraversal(bst.root));\n// [3, 5, 7, 10, 13, 15, 17] - tri√© !\n```\n\n### 2. Parcours Pr√©fixe (Pre-Order)\n\n**Ordre** : Racine ‚Üí Gauche ‚Üí Droite  \n**Usage** : Copier un arbre, expressions pr√©fix√©es\n\n```javascript\nfunction preOrderTraversal(node, result = []) {\n  if (node) {\n    result.push(node.value);\n    preOrderTraversal(node.left, result);\n    preOrderTraversal(node.right, result);\n  }\n  return result;\n}\n\nconsole.log(preOrderTraversal(bst.root));\n// [10, 5, 3, 7, 15, 13, 17]\n```\n\n### 3. Parcours Postfixe (Post-Order)\n\n**Ordre** : Gauche ‚Üí Droite ‚Üí Racine  \n**Usage** : Supprimer un arbre, expressions postfix√©es\n\n```javascript\nfunction postOrderTraversal(node, result = []) {\n  if (node) {\n    postOrderTraversal(node.left, result);\n    postOrderTraversal(node.right, result);\n    result.push(node.value);\n  }\n  return result;\n}\n\nconsole.log(postOrderTraversal(bst.root));\n// [3, 7, 5, 13, 17, 15, 10]\n```\n\n### 4. Parcours en Largeur (Level-Order / BFS)\n\n```javascript\nfunction levelOrderTraversal(root) {\n  if (!root) return [];\n\n  const result = [];\n  const queue = [root];\n\n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    const currentLevel = [];\n\n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      currentLevel.push(node.value);\n\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n\n    result.push(currentLevel);\n  }\n\n  return result;\n}\n\nconsole.log(levelOrderTraversal(bst.root));\n// [[10], [5, 15], [3, 7, 13, 17]]\n```\n\n---\n\n## üìä Propri√©t√©s et Analyse\n\n### Hauteur et Profondeur\n\n```javascript\n// Hauteur d'un n≈ìud (longueur du plus long chemin descendant)\nfunction getHeight(node) {\n  if (!node) return -1;\n  return 1 + Math.max(getHeight(node.left), getHeight(node.right));\n}\n\n// Profondeur d'un n≈ìud (distance depuis la racine)\nfunction getDepth(root, target, depth = 0) {\n  if (!root) return -1;\n  if (root.value === target) return depth;\n\n  const leftDepth = getDepth(root.left, target, depth + 1);\n  if (leftDepth !== -1) return leftDepth;\n\n  return getDepth(root.right, target, depth + 1);\n}\n\n// V√©rifier si l'arbre est √©quilibr√©\nfunction isBalanced(root) {\n  function checkBalance(node) {\n    if (!node) return { height: -1, balanced: true };\n\n    const left = checkBalance(node.left);\n    const right = checkBalance(node.right);\n\n    const height = 1 + Math.max(left.height, right.height);\n    const balanced = left.balanced && right.balanced &&\n                     Math.abs(left.height - right.height) <= 1;\n\n    return { height, balanced };\n  }\n\n  return checkBalance(root).balanced;\n}\n```\n\n### Complexit√© des Op√©rations\n\n| Op√©ration | Meilleur Cas | Pire Cas | Cas Moyen |\n|-----------|-------------|----------|-----------|\n| **Recherche** | O(log n) | O(n) | O(log n) |\n| **Insertion** | O(log n) | O(n) | O(log n) |\n| **Suppression** | O(log n) | O(n) | O(log n) |\n| **Parcours** | O(n) | O(n) | O(n) |\n\n**Note** : Le pire cas (O(n)) survient quand l'arbre d√©g√©n√®re en liste cha√Æn√©e.\n\n---\n\n## üíª Exercices Pratiques\n\n### Exercice 1 : V√©rifier si un BST est Valide\n\n**Objectif** : V√©rifier que l'arbre respecte la propri√©t√© BST.\n\n```javascript\nfunction isValidBST(root, min = -Infinity, max = Infinity) {\n  if (!root) return true;\n\n  if (root.value <= min || root.value >= max) {\n    return false;\n  }\n\n  return isValidBST(root.left, min, root.value) &&\n         isValidBST(root.right, root.value, max);\n}\n\n// Test\nconst bst = new BinarySearchTree();\n[10, 5, 15, 3, 7].forEach(val => bst.insert(val));\nconsole.log(isValidBST(bst.root)); // true\n```\n\n### Exercice 2 : Trouver le k-i√®me Plus Petit √âl√©ment\n\n```javascript\nfunction kthSmallest(root, k) {\n  let count = 0;\n  let result = null;\n\n  function inOrder(node) {\n    if (!node || result !== null) return;\n\n    inOrder(node.left);\n\n    count++;\n    if (count === k) {\n      result = node.value;\n      return;\n    }\n\n    inOrder(node.right);\n  }\n\n  inOrder(root);\n  return result;\n}\n\n// Test\nconsole.log(kthSmallest(bst.root, 3)); // 7 (3√®me plus petit)\n```\n\n### Exercice 3 : Convertir un Tableau Tri√© en BST √âquilibr√©\n\n```javascript\nfunction sortedArrayToBST(nums, start = 0, end = nums.length - 1) {\n  if (start > end) return null;\n\n  const mid = Math.floor((start + end) / 2);\n  const root = new Node(nums[mid]);\n\n  root.left = sortedArrayToBST(nums, start, mid - 1);\n  root.right = sortedArrayToBST(nums, mid + 1, end);\n\n  return root;\n}\n\n// Test\nconst nums = [1, 2, 3, 4, 5, 6, 7];\nconst root = sortedArrayToBST(nums);\nconsole.log(inOrderTraversal(root)); // [1, 2, 3, 4, 5, 6, 7]\n```\n\n### Exercice 4 : Anc√™tre Commun le Plus Bas (LCA)\n\n```javascript\nfunction lowestCommonAncestor(root, p, q) {\n  if (!root || root.value === p || root.value === q) {\n    return root;\n  }\n\n  const left = lowestCommonAncestor(root.left, p, q);\n  const right = lowestCommonAncestor(root.right, p, q);\n\n  if (left && right) return root;\n  return left || right;\n}\n\n// Test\nconsole.log(lowestCommonAncestor(bst.root, 3, 7).value); // 5\nconsole.log(lowestCommonAncestor(bst.root, 3, 13).value); // 10\n```\n\n### Exercice 5 : Inverser un BST\n\n```javascript\nfunction invertTree(root) {\n  if (!root) return null;\n\n  // √âchanger les sous-arbres\n  [root.left, root.right] = [root.right, root.left];\n\n  // Inverser r√©cursivement\n  invertTree(root.left);\n  invertTree(root.right);\n\n  return root;\n}\n\n// Test\nconst original = inOrderTraversal(bst.root);\ninvertTree(bst.root);\nconst inverted = inOrderTraversal(bst.root);\nconsole.log(\"Original:\", original);\nconsole.log(\"Inverted:\", inverted);\n```\n\n---\n\n## üåü Applications R√©elles\n\n### 1. Syst√®mes de Base de Donn√©es\n\n```javascript\nclass DatabaseIndex {\n  constructor() {\n    this.index = new BinarySearchTree();\n  }\n\n  insertRecord(id, data) {\n    this.index.insert(id);\n    // Stocker data dans la vraie base\n  }\n\n  findRecord(id) {\n    return this.index.contains(id);\n  }\n\n  // Recherche par plage\n  findInRange(min, max) {\n    const results = [];\n\n    function collectInRange(node) {\n      if (!node) return;\n\n      if (node.value >= min) {\n        collectInRange(node.left);\n      }\n\n      if (node.value >= min && node.value <= max) {\n        results.push(node.value);\n      }\n\n      if (node.value <= max) {\n        collectInRange(node.right);\n      }\n    }\n\n    collectInRange(this.index.root);\n    return results;\n  }\n}\n```\n\n### 2. Syst√®me de Fichiers Hi√©rarchique\n\n```javascript\nclass FileSystem {\n  constructor() {\n    this.root = null;\n  }\n\n  insertPath(path) {\n    const parts = path.split('/').filter(p => p);\n    let current = this.root;\n\n    for (let part of parts) {\n      if (!current) {\n        current = new Node(part);\n        this.root = current;\n      } else {\n        // Ins√©rer dans l'arbre (logique simplifi√©e)\n        if (part < current.value) {\n          if (!current.left) current.left = new Node(part);\n          current = current.left;\n        } else {\n          if (!current.right) current.right = new Node(part);\n          current = current.right;\n        }\n      }\n    }\n  }\n\n  listPaths() {\n    const paths = [];\n\n    function collectPaths(node, currentPath = '') {\n      if (!node) return;\n\n      const newPath = currentPath + '/' + node.value;\n\n      if (!node.left && !node.right) {\n        // Feuille = fichier\n        paths.push(newPath);\n      }\n\n      collectPaths(node.left, newPath);\n      collectPaths(node.right, newPath);\n    }\n\n    collectPaths(this.root);\n    return paths;\n  }\n}\n```\n\n### 3. Correction Orthographique (Suggestion de Mots)\n\n```javascript\nclass SpellChecker {\n  constructor() {\n    this.dictionary = new BinarySearchTree();\n  }\n\n  addWord(word) {\n    this.dictionary.insert(word.toLowerCase());\n  }\n\n  // Trouver le mot le plus proche (distance d'√©dition simplifi√©e)\n  findClosest(word) {\n    word = word.toLowerCase();\n    let closest = null;\n    let minDistance = Infinity;\n\n    function checkWord(node) {\n      if (!node) return;\n\n      const distance = levenshteinDistance(word, node.value);\n      if (distance < minDistance) {\n        minDistance = distance;\n        closest = node.value;\n      }\n\n      // Optimisation : ne visiter que les branches pertinentes\n      if (word < node.value) {\n        checkWord(node.left);\n      } else {\n        checkWord(node.right);\n      }\n    }\n\n    checkWord(this.dictionary.root);\n    return closest;\n  }\n}\n\nfunction levenshteinDistance(a, b) {\n  // Distance d'√©dition simplifi√©e\n  if (a.length === 0) return b.length;\n  if (b.length === 0) return a.length;\n\n  return Math.min(\n    levenshteinDistance(a.slice(1), b) + 1,      // Suppression\n    levenshteinDistance(a, b.slice(1)) + 1,      // Insertion\n    levenshteinDistance(a.slice(1), b.slice(1)) + (a[0] === b[0] ? 0 : 1) // Substitution\n  );\n}\n```\n\n---\n\n## ‚öñÔ∏è Comparaison avec Autres Structures\n\n| Structure | Recherche | Insertion | Tri Auto | √âquilibrage |\n|-----------|-----------|-----------|----------|-------------|\n| **BST** | O(log n)* | O(log n)* | ‚úÖ | ‚ùå |\n| **Arbre AVL** | O(log n) | O(log n) | ‚úÖ | ‚úÖ |\n| **Arbre Rouge-Noir** | O(log n) | O(log n) | ‚úÖ | ‚úÖ |\n| **Table de hachage** | O(1) | O(1) | ‚ùå | N/A |\n| **Tableau tri√©** | O(log n) | O(n) | ‚úÖ | N/A |\n\n*Peut d√©g√©n√©rer en O(n) si non √©quilibr√©\n\n---\n\n## üîç Probl√®mes Avanc√©s\n\n### Probl√®me : S√©rialisation/D√©s√©rialisation d'un BST\n\n```javascript\n// Convertir arbre en cha√Æne\nfunction serialize(root) {\n  if (!root) return 'null';\n\n  const left = serialize(root.left);\n  const right = serialize(root.right);\n\n  return `${root.value},${left},${right}`;\n}\n\n// Reconstruire arbre depuis cha√Æne\nfunction deserialize(data) {\n  const values = data.split(',');\n\n  function build() {\n    const val = values.shift();\n    if (val === 'null') return null;\n\n    const node = new Node(parseInt(val));\n    node.left = build();\n    node.right = build();\n    return node;\n  }\n\n  return build();\n}\n\n// Test\nconst bst = new BinarySearchTree();\n[5, 3, 7, 2, 4, 6, 8].forEach(val => bst.insert(val));\n\nconst serialized = serialize(bst.root);\nconsole.log(\"S√©rialis√©:\", serialized);\n\nconst deserialized = deserialize(serialized);\nconsole.log(\"D√©s√©rialis√©:\", inOrderTraversal(deserialized));\n```\n\n---\n\n## üìù Quiz de R√©vision\n\n### Question 1\nQuelle propri√©t√© d√©finit un arbre binaire de recherche ?\n- A) Racine √† gauche\n- B) Valeurs gauches ‚â§ racine < valeurs droites  ‚Üê **R√©ponse**\n- C) Hauteur maximale 3\n- D) Un seul enfant par n≈ìud\n\n### Question 2\nQuel parcours donne les valeurs dans l'ordre tri√© ?\n- A) Pr√©fixe\n- B) Infixe  ‚Üê **R√©ponse**\n- C) Postfixe\n- D) En largeur\n\n### Question 3\nQuelle est la complexit√© moyenne d'une recherche dans un BST √©quilibr√© ?\n- A) O(1)\n- B) O(log n)  ‚Üê **R√©ponse**\n- C) O(n)\n- D) O(n¬≤)\n\n### Question 4\nDans quel cas un BST peut-il d√©g√©n√©rer en liste cha√Æn√©e ?\n- A) Insertion dans l'ordre croissant  ‚Üê **R√©ponse**\n- B) Insertion al√©atoire\n- C) Suppression √©quilibr√©e\n- D) Parcours en largeur\n\n---\n\n## üîë Points Cl√©s √† Retenir\n\n1. **BST** = arbre binaire avec propri√©t√© d'ordre\n2. **Op√©rations** : insertion, recherche, suppression en O(log n) moyen\n3. **Parcours** : in-order = tri√©, pre/post-order = structure\n4. **Probl√®me** : peut d√©g√©n√©rer si insertions ordonn√©es\n5. **Solutions** : AVL, rouge-noir pour √©quilibrage automatique\n6. **Applications** : bases de donn√©es, syst√®mes de fichiers, correction orthographique\n\n---\n\n*Chapitre suivant : [Arbres AVL](09-avl-trees.md)*\n",
  "12": "# Chapitre 12 : Les Graphes\n\n## üåê Probl√®me √† R√©soudre\n\nCertaines donn√©es ne sont pas hi√©rarchiques (comme les arbres) mais **r√©seaut√©es** :\n\n- R√©seaux sociaux ‚Üí amis, abonn√©s\n- GPS ‚Üí routes entre villes\n- Internet ‚Üí pages li√©es entre elles\n\nüëâ Pour mod√©liser ce type de relations complexes, on utilise les **graphes**.\n\n---\n\n## üìä D√©finition d'un Graphe\n\nUn **graphe** est un ensemble de :\n\n- **Sommets** (n≈ìuds/vertices) : entit√©s (villes, personnes, pages web)\n- **Ar√™tes** (edges) : connexions entre sommets\n\n### Types de Graphes\n\nUn graphe peut √™tre :\n\n- **Orient√©** : chaque ar√™te a un sens (ex. Twitter : \"je te suis\" ‚â† \"tu me suis\")\n- **Non orient√©** : ar√™tes bidirectionnelles (ex. Facebook : \"amis\")\n- **Pond√©r√©** : chaque ar√™te a un co√ªt (distance, temps, poids)\n- **Non pond√©r√©** : simple connexion sans co√ªt\n\n### Exemple de Graphe\n\n#### Graphe Non Orient√©\n```\n   (A) ‚Äî‚Äî (B)\n    |     / |\n    |    /  |\n   (C) ‚Äî‚Äî (D)\n```\n\n#### Graphe Orient√©\n```\n   (A) ‚Üí (B)\n    ‚Üì      ‚Üë\n   (C) ‚Üí (D)\n```\n\n---\n\n## üíæ Repr√©sentation en Informatique\n\n### 1. Liste d'Adjacence (Recommand√©e)\n\nChaque sommet pointe vers ses voisins.\n\n```javascript\n// Graphe non orient√©\nconst graphe = {\n  A: [\"B\", \"C\"],\n  B: [\"A\", \"D\"],\n  C: [\"A\", \"D\"],\n  D: [\"B\", \"C\"]\n};\n\n// Graphe orient√©\nconst grapheOriented = {\n  A: [\"B\", \"C\"],\n  B: [\"D\"],\n  C: [\"D\"],\n  D: []\n};\n\n// Graphe pond√©r√©\nconst graphePondere = {\n  A: [{sommet: \"B\", poids: 4}, {sommet: \"C\", poids: 2}],\n  B: [{sommet: \"A\", poids: 4}, {sommet: \"D\", poids: 5}],\n  C: [{sommet: \"A\", poids: 2}, {sommet: \"D\", poids: 1}],\n  D: [{sommet: \"B\", poids: 5}, {sommet: \"C\", poids: 1}]\n};\n```\n\n### 2. Matrice d'Adjacence\n\nTableau 2D o√π matrice[i][j] = 1 si connexion entre i et j.\n\n```javascript\n// Pour les sommets A, B, C, D\nconst matrice = [\n  // A  B  C  D\n  [ 0, 1, 1, 0 ], // A\n  [ 1, 0, 0, 1 ], // B\n  [ 1, 0, 0, 1 ], // C\n  [ 0, 1, 1, 0 ]  // D\n];\n\n// Acc√®s : matrice[0][1] = 1 signifie A connect√© √† B\n```\n\n**Comparaison** :\n- **Liste** : √©conome en m√©moire pour graphes clairsem√©s\n- **Matrice** : acc√®s O(1), mais O(n¬≤) m√©moire m√™me pour graphes vides\n\n---\n\n## üîç Parcours de Graphes\n\n### 1. Parcours en Largeur (BFS - Breadth First Search)\n\nüëâ Explore \"couche par couche\".\n\n- Utilise une **file** (queue)\n- Utile pour trouver le **plus court chemin non pond√©r√©**\n\n```javascript\nfunction parcoursLargeur(graphe, depart) {\n  const visites = new Set();\n  const file = [];\n\n  file.push(depart);\n  visites.add(depart);\n\n  while (file.length > 0) {\n    const sommet = file.shift();\n    console.log(sommet);\n\n    // Ajouter les voisins non visit√©s\n    for (let voisin of graphe[sommet] || []) {\n      if (!visites.has(voisin)) {\n        visites.add(voisin);\n        file.push(voisin);\n      }\n    }\n  }\n}\n\n// Exemple\nconst reseau = {\n  A: [\"B\", \"C\"],\n  B: [\"A\", \"D\"],\n  C: [\"A\", \"D\"],\n  D: [\"B\", \"C\"]\n};\n\nparcoursLargeur(reseau, \"A\"); // A, B, C, D\n```\n\n### 2. Parcours en Profondeur (DFS - Depth First Search)\n\nüëâ Explore \"jusqu'au bout d'un chemin\" avant de revenir.\n\n- Utilise une **pile** (stack) ou **r√©cursivit√©**\n- Utile pour d√©tecter des **cycles**, **composants connexes**\n\n```javascript\nfunction parcoursProfondeur(graphe, sommet, visites = new Set()) {\n  if (visites.has(sommet)) return;\n\n  console.log(sommet);\n  visites.add(sommet);\n\n  for (let voisin of graphe[sommet] || []) {\n    parcoursProfondeur(graphe, voisin, visites);\n  }\n}\n\n// Version it√©rative\nfunction parcoursProfondeurIteratif(graphe, depart) {\n  const visites = new Set();\n  const pile = [depart];\n\n  while (pile.length > 0) {\n    const sommet = pile.pop();\n\n    if (!visites.has(sommet)) {\n      console.log(sommet);\n      visites.add(sommet);\n\n      // Ajouter les voisins (dans l'ordre inverse pour garder la logique)\n      for (let voisin of (graphe[sommet] || []).reverse()) {\n        if (!visites.has(voisin)) {\n          pile.push(voisin);\n        }\n      }\n    }\n  }\n}\n\nparcoursProfondeur(reseau, \"A\"); // A, B, D, C (selon l'ordre)\n```\n\n---\n\n## üîç Applications Pratiques\n\n### 1. R√©seaux Sociaux - Suggestion d'Amis\n\n```javascript\nfunction suggererAmis(graphe, utilisateur, degre = 2) {\n  const visites = new Set();\n  const suggestions = new Map();\n\n  function explorer(sommet, distance) {\n    if (distance > degre || visites.has(sommet)) return;\n\n    visites.add(sommet);\n\n    if (distance > 0 && distance <= degre) {\n      suggestions.set(sommet, distance);\n    }\n\n    for (let ami of graphe[sommet] || []) {\n      explorer(ami, distance + 1);\n    }\n  }\n\n  explorer(utilisateur, 0);\n  suggestions.delete(utilisateur); // Ne pas se sugg√©rer soi-m√™me\n\n  return Array.from(suggestions.entries())\n    .sort((a, b) => a[1] - b[1]); // Trier par proximit√©\n}\n\n// Exemple\nconst reseauSocial = {\n  Alice: [\"Bob\", \"Charlie\"],\n  Bob: [\"Alice\", \"Diana\", \"Eve\"],\n  Charlie: [\"Alice\", \"Diana\"],\n  Diana: [\"Bob\", \"Charlie\", \"Eve\"],\n  Eve: [\"Bob\", \"Diana\"],\n  Frank: [\"Grace\"] // Island\n};\n\nconsole.log(suggererAmis(reseauSocial, \"Alice\"));\n// [[\"Bob\", 1], [\"Charlie\", 1], [\"Diana\", 2], [\"Eve\", 2]]\n```\n\n### 2. D√©tection de Cycles\n\n```javascript\nfunction contientCycle(graphe) {\n  const visites = new Set();\n  const enCours = new Set();\n\n  function dfsCycle(sommet) {\n    visites.add(sommet);\n    enCours.add(sommet);\n\n    for (let voisin of graphe[sommet] || []) {\n      if (!visites.has(voisin)) {\n        if (dfsCycle(voisin)) return true;\n      } else if (enCours.has(voisin)) {\n        return true; // Cycle d√©tect√©\n      }\n    }\n\n    enCours.delete(sommet);\n    return false;\n  }\n\n  for (let sommet of Object.keys(graphe)) {\n    if (!visites.has(sommet)) {\n      if (dfsCycle(sommet)) return true;\n    }\n  }\n\n  return false;\n}\n\n// Test\nconst grapheAcyclique = {\n  A: [\"B\", \"C\"],\n  B: [\"D\"],\n  C: [\"D\"],\n  D: []\n};\n\nconst grapheCyclique = {\n  A: [\"B\"],\n  B: [\"C\"],\n  C: [\"A\"] // Cycle A -> B -> C -> A\n};\n\nconsole.log(contientCycle(grapheAcyclique)); // false\nconsole.log(contientCycle(grapheCyclique)); // true\n```\n\n### 3. Composants Connexes\n\n```javascript\nfunction composantsConnexes(graphe) {\n  const visites = new Set();\n  const composants = [];\n\n  function dfs(sommet, composant) {\n    visites.add(sommet);\n    composant.push(sommet);\n\n    for (let voisin of graphe[sommet] || []) {\n      if (!visites.has(voisin)) {\n        dfs(voisin, composant);\n      }\n    }\n  }\n\n  for (let sommet of Object.keys(graphe)) {\n    if (!visites.has(sommet)) {\n      const composant = [];\n      dfs(sommet, composant);\n      composants.push(composant);\n    }\n  }\n\n  return composants;\n}\n\n// Exemple\nconst grapheDecconex = {\n  A: [\"B\", \"C\"],\n  B: [\"A\", \"C\"],\n  C: [\"A\", \"B\"],\n  D: [\"E\"],     // Composant s√©par√©\n  E: [\"D\"],\n  F: []         // Sommet isol√©\n};\n\nconsole.log(composantsConnexes(grapheDecconex));\n// [[\"A\", \"B\", \"C\"], [\"D\", \"E\"], [\"F\"]]\n```\n\n---\n\n## üíª Exercice Pratique 1\n\n**Objectif** : Impl√©mentez une fonction `hasPath(graph, start, end)` qui retourne `true` si un chemin existe entre `start` et `end`.\n\nUtilisez **DFS** pour la premi√®re version, **BFS** pour la deuxi√®me.\n\n### Solution DFS :\n```javascript\nfunction hasPathDFS(graph, start, end, visited = new Set()) {\n  if (start === end) return true;\n  if (visited.has(start)) return false;\n\n  visited.add(start);\n\n  for (let neighbor of graph[start] || []) {\n    if (hasPathDFS(graph, neighbor, end, visited)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n```\n\n### Solution BFS :\n```javascript\nfunction hasPathBFS(graph, start, end) {\n  const visited = new Set();\n  const queue = [start];\n  visited.add(start);\n\n  while (queue.length > 0) {\n    const current = queue.shift();\n\n    if (current === end) return true;\n\n    for (let neighbor of graph[current] || []) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  return false;\n}\n\n// Tests\nconst graph = {\n  A: [\"B\", \"C\"],\n  B: [\"A\", \"D\"],\n  C: [\"A\", \"D\"],\n  D: [\"B\", \"C\"],\n  E: [\"F\"],\n  F: [\"E\"]\n};\n\nconsole.log(hasPathDFS(graph, \"A\", \"D\")); // true\nconsole.log(hasPathBFS(graph, \"A\", \"E\")); // false\n```\n\n---\n\n## üíª Exercice Pratique 2\n\n**Objectif** : Impl√©mentez une fonction qui trouve le plus court chemin non pond√©r√© entre deux sommets.\n\n### Solution :\n```javascript\nfunction plusCourtChemin(graph, start, end) {\n  const visited = new Set();\n  const queue = [[start, [start]]]; // [sommet, chemin]\n  visited.add(start);\n\n  while (queue.length > 0) {\n    const [current, path] = queue.shift();\n\n    if (current === end) {\n      return path;\n    }\n\n    for (let neighbor of graph[current] || []) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push([neighbor, [...path, neighbor]]);\n      }\n    }\n  }\n\n  return null; // Pas de chemin\n}\n\nconsole.log(plusCourtChemin(graph, \"A\", \"D\")); // [\"A\", \"B\", \"D\"] ou [\"A\", \"C\", \"D\"]\n```\n\n---\n\n### Exercice 3 : D√©tection de Cycles\n\n**Objectif** : Impl√©mentez une fonction qui d√©tecte si un graphe contient un cycle.\n\n**Consignes** :\n- Utiliser DFS avec coloriage des n≈ìuds (Blanc, Gris, Noir)\n- Un cycle est d√©tect√© si on trouve un arc vers un n≈ìud Gris\n- Tester avec diff√©rents graphes\n\n```javascript\nfunction detecteCycle(graph) {\n    // TODO: impl√©menter la d√©tection de cycles\n}\n\n// Graphes de test\nconst grapheAcyclique = {\n    A: ['B', 'C'],\n    B: ['D'],\n    C: ['D'],\n    D: []\n};\n\nconst grapheCyclique = {\n    A: ['B'],\n    B: ['C'],\n    C: ['A', 'D'],\n    D: []\n};\n\nconsole.log(detecteCycle(grapheAcyclique)); // false\nconsole.log(detecteCycle(grapheCyclique)); // true\n```\n\n### Solution :\n```javascript\nfunction detecteCycle(graph) {\n    const visited = new Set();\n    const recStack = new Set();\n\n    function dfs(node) {\n        visited.add(node);\n        recStack.add(node);\n\n        for (let neighbor of graph[node] || []) {\n            if (!visited.has(neighbor)) {\n                if (dfs(neighbor)) {\n                    return true;\n                }\n            } else if (recStack.has(neighbor)) {\n                // Cycle d√©tect√© !\n                return true;\n            }\n        }\n\n        recStack.delete(node);\n        return false;\n    }\n\n    // Tester tous les n≈ìuds (au cas o√π le graphe serait d√©connect√©)\n    for (let node in graph) {\n        if (!visited.has(node)) {\n            if (dfs(node)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// Tests √©tendus\nconst tests = [\n    {\n        name: \"Graphe acyclique simple\",\n        graph: { A: ['B'], B: ['C'], C: [] },\n        expected: false\n    },\n    {\n        name: \"Graphe avec cycle\",\n        graph: { A: ['B'], B: ['C'], C: ['A'] },\n        expected: true\n    },\n    {\n        name: \"Graphe d√©connect√© sans cycle\",\n        graph: { A: ['B'], B: [], C: ['D'], D: [] },\n        expected: false\n    },\n    {\n        name: \"Graphe d√©connect√© avec cycle\",\n        graph: { A: ['B'], B: ['A'], C: ['D'], D: ['C'] },\n        expected: true\n    }\n];\n\nconsole.log(\"üåÄ Tests de d√©tection de cycles:\");\ntests.forEach(test => {\n    const result = detecteCycle(test.graph);\n    const status = result === test.expected ? \"‚úÖ\" : \"‚ùå\";\n    console.log(`${status} ${test.name}: ${result} (attendu: ${test.expected})`);\n});\n```\n\n---\n\n### Exercice 4 : Composantes Connexes\n\n**Objectif** : Trouver toutes les composantes connexes d'un graphe.\n\n**Consignes** :\n- Utiliser DFS ou BFS pour explorer chaque composante\n- Retourner une liste des composantes\n- Tester avec un graphe d√©connect√©\n\n```javascript\nfunction composantesConnexes(graph) {\n    // TODO: impl√©menter\n}\n\n// Test\nconst grapheDeconnecte = {\n    A: ['B'],\n    B: ['A'],\n    C: ['D'],\n    D: ['C', 'E'],\n    E: ['D'],\n    F: [] // N≈ìud isol√©\n};\n\nconsole.log(composantesConnexes(grapheDeconnecte));\n// R√©sultat attendu: [['A', 'B'], ['C', 'D', 'E'], ['F']]\n```\n\n### Solution :\n```javascript\nfunction composantesConnexes(graph) {\n    const visited = new Set();\n    const composantes = [];\n\n    function dfs(node, composante) {\n        visited.add(node);\n        composante.push(node);\n\n        for (let neighbor of graph[node] || []) {\n            if (!visited.has(neighbor)) {\n                dfs(neighbor, composante);\n            }\n        }\n    }\n\n    // Parcourir tous les n≈ìuds\n    for (let node in graph) {\n        if (!visited.has(node)) {\n            const composante = [];\n            dfs(node, composante);\n            composantes.push(composante.sort()); // Trier pour la coh√©rence\n        }\n    }\n\n    return composantes.sort((a, b) => a.length - b.length); // Trier par taille\n}\n\n// Fonction alternative avec BFS\nfunction composantesConnexesBFS(graph) {\n    const visited = new Set();\n    const composantes = [];\n\n    for (let node in graph) {\n        if (!visited.has(node)) {\n            const composante = [];\n            const queue = [node];\n            visited.add(node);\n\n            while (queue.length > 0) {\n                const current = queue.shift();\n                composante.push(current);\n\n                for (let neighbor of graph[current] || []) {\n                    if (!visited.has(neighbor)) {\n                        visited.add(neighbor);\n                        queue.push(neighbor);\n                    }\n                }\n            }\n\n            composantes.push(composante.sort());\n        }\n    }\n\n    return composantes.sort((a, b) => a.length - b.length);\n}\n\n// Tests\nconst grapheDeconnecte = {\n    A: ['B'],\n    B: ['A'],\n    C: ['D'],\n    D: ['C', 'E'],\n    E: ['D'],\n    F: [] // N≈ìud isol√©\n};\n\nconsole.log(\"üîó Composantes connexes (DFS):\");\nconsole.log(composantesConnexes(grapheDeconnecte));\n\nconsole.log(\"üîó Composantes connexes (BFS):\");\nconsole.log(composantesConnexesBFS(grapheDeconnecte));\n\n// Test avec graphe vide\nconsole.log(\"üîó Graphe vide:\");\nconsole.log(composantesConnexes({}));\n\n// Test avec un seul n≈ìud\nconsole.log(\"üîó Un seul n≈ìud:\");\nconsole.log(composantesConnexes({ A: [] }));\n```\n\n---\n\n### Exercice 5 : Graphe Pond√©r√© - Algorithme de Prim\n\n**Objectif** : Impl√©menter l'algorithme de Prim pour trouver l'arbre couvrant de poids minimal.\n\n**Consignes** :\n- Repr√©senter le graphe avec des poids sur les ar√™tes\n- Utiliser une file de priorit√© pour s√©lectionner l'ar√™te de poids minimal\n- Construire l'arbre couvrant minimum\n\n```javascript\n// Repr√©sentation d'un graphe pond√©r√©\nconst graphePondere = {\n    A: [{ vers: 'B', poids: 4 }, { vers: 'C', poids: 2 }],\n    B: [{ vers: 'A', poids: 4 }, { vers: 'C', poids: 1 }, { vers: 'D', poids: 5 }],\n    C: [{ vers: 'A', poids: 2 }, { vers: 'B', poids: 1 }, { vers: 'D', poids: 8 }],\n    D: [{ vers: 'B', poids: 5 }, { vers: 'C', poids: 8 }]\n};\n\nfunction arbreCouvrantPrim(graph, start) {\n    // TODO: impl√©menter l'algorithme de Prim\n}\n\nconsole.log(arbreCouvrantPrim(graphePondere, 'A'));\n```\n\n### Solution :\n```javascript\nfunction arbreCouvrantPrim(graph, start) {\n    const mst = []; // Ar√™tes de l'arbre couvrant\n    const visited = new Set();\n    const minHeap = new PriorityQueue();\n\n    visited.add(start);\n\n    // Ajouter toutes les ar√™tes du n≈ìud de d√©part\n    for (let edge of graph[start] || []) {\n        minHeap.push({ poids: edge.poids, de: start, vers: edge.vers });\n    }\n\n    while (!minHeap.isEmpty() && visited.size < Object.keys(graph).length) {\n        const edge = minHeap.pop();\n\n        if (visited.has(edge.vers)) {\n            continue; // Cette ar√™te cr√©erait un cycle\n        }\n\n        // Ajouter l'ar√™te √† l'arbre couvrant\n        mst.push(edge);\n        visited.add(edge.vers);\n\n        // Ajouter les nouvelles ar√™tes disponibles\n        for (let newEdge of graph[edge.vers] || []) {\n            if (!visited.has(newEdge.vers)) {\n                minHeap.push({\n                    poids: newEdge.poids,\n                    de: edge.vers,\n                    vers: newEdge.vers\n                });\n            }\n        }\n    }\n\n    return mst;\n}\n\n// File de priorit√© simple (min-heap)\nclass PriorityQueue {\n    constructor() {\n        this.values = [];\n    }\n\n    push(element) {\n        this.values.push(element);\n        this.bubbleUp();\n    }\n\n    pop() {\n        if (this.values.length === 0) return null;\n\n        const min = this.values[0];\n        const end = this.values.pop();\n\n        if (this.values.length > 0) {\n            this.values[0] = end;\n            this.sinkDown();\n        }\n\n        return min;\n    }\n\n    bubbleUp() {\n        let index = this.values.length - 1;\n        const element = this.values[index];\n\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            const parent = this.values[parentIndex];\n\n            if (element.poids >= parent.poids) break;\n\n            this.values[parentIndex] = element;\n            this.values[index] = parent;\n            index = parentIndex;\n        }\n    }\n\n    sinkDown() {\n        let index = 0;\n        const length = this.values.length;\n        const element = this.values[0];\n\n        while (true) {\n            const leftChildIndex = 2 * index + 1;\n            const rightChildIndex = 2 * index + 2;\n            let leftChild, rightChild;\n            let swapIndex = null;\n\n            if (leftChildIndex < length) {\n                leftChild = this.values[leftChildIndex];\n                if (leftChild.poids < element.poids) {\n                    swapIndex = leftChildIndex;\n                }\n            }\n\n            if (rightChildIndex < length) {\n                rightChild = this.values[rightChildIndex];\n                if (\n                    (swapIndex === null && rightChild.poids < element.poids) ||\n                    (swapIndex !== null && rightChild.poids < leftChild.poids)\n                ) {\n                    swapIndex = rightChildIndex;\n                }\n            }\n\n            if (swapIndex === null) break;\n\n            this.values[index] = this.values[swapIndex];\n            this.values[swapIndex] = element;\n            index = swapIndex;\n        }\n    }\n\n    isEmpty() {\n        return this.values.length === 0;\n    }\n}\n\n// Test de l'algorithme de Prim\nconst graphePondere = {\n    A: [{ vers: 'B', poids: 4 }, { vers: 'C', poids: 2 }],\n    B: [{ vers: 'A', poids: 4 }, { vers: 'C', poids: 1 }, { vers: 'D', poids: 5 }],\n    C: [{ vers: 'A', poids: 2 }, { vers: 'B', poids: 1 }, { vers: 'D', poids: 8 }],\n    D: [{ vers: 'B', poids: 5 }, { vers: 'C', poids: 8 }]\n};\n\nconsole.log(\"üå≤ Arbre couvrant minimum (Prim):\");\nconst mst = arbreCouvrantPrim(graphePondere, 'A');\n\nlet totalWeight = 0;\nconsole.log(\"Ar√™tes de l'arbre couvrant:\");\nmst.forEach(edge => {\n    console.log(`   ${edge.de} --(${edge.poids})-- ${edge.vers}`);\n    totalWeight += edge.poids;\n});\n\nconsole.log(`Poids total: ${totalWeight}`);\n\n// V√©rification: devrait √™tre 2 + 1 + 5 = 8\nconsole.log(\"V√©rification: A-C(2) + B-C(1) + B-D(5) = 8 ‚úì\");\n```\n\n---\n\n## üìä Analyse de Complexit√©\n\n| Algorithme | Complexit√© Temps | Complexit√© Espace |\n|------------|------------------|-------------------|\n| **BFS** | O(V + E) | O(V) |\n| **DFS** | O(V + E) | O(V) |\n\nO√π :\n- **V** = nombre de sommets (vertices)\n- **E** = nombre d'ar√™tes (edges)\n\n---\n\n## üåü Cas d'Usage R√©els\n\n- **GPS** (Google Maps, Waze) ‚Üí trouver l'itin√©raire le plus court\n- **R√©seaux sociaux** ‚Üí suggestion d'amis\n- **IA** (jeux vid√©o) ‚Üí d√©placement de personnages\n- **Internet** (PageRank de Google) ‚Üí importance des pages web\n- **R√©seaux informatiques** ‚Üí routage des paquets\n- **Base de donn√©es** ‚Üí optimisation de requ√™tes\n\n---\n\n## üìù Quiz de R√©vision\n\n### Question 1\nQuelle est la diff√©rence entre un graphe orient√© et non orient√© ?\n- A) L'orientation change la complexit√©\n- B) Les ar√™tes orient√©es sont √† sens unique  ‚Üê **R√©ponse**\n- C) Les graphes orient√©s utilisent plus de m√©moire\n- D) Aucune diff√©rence pratique\n\n### Question 2\nQuelle repr√©sentation est la plus √©conome en m√©moire pour un graphe clairsem√© ?\n- A) Matrice d'adjacence\n- B) Liste d'adjacence  ‚Üê **R√©ponse**\n- C) Liste de successeurs\n- D) Tableau de pointeurs\n\n### Question 3\nQuel algorithme de parcours est le plus adapt√© pour trouver un plus court chemin non pond√©r√© ?\n- A) DFS\n- B) BFS  ‚Üê **R√©ponse**\n- C) Dijkstra\n- D) A*\n\n### Question 4\nDans un graphe, que signifie \"V + E\" dans la complexit√© ?\n- A) Nombre maximum de sommets\n- B) Sommets + Ar√™tes  ‚Üê **R√©ponse**\n- C) Visites + Explorations\n- D) Variables + √âquations\n\n---\n\n## üîë Points Cl√©s √† Retenir\n\n1. **Graphe** = ensemble de sommets connect√©s par des ar√™tes\n2. **Repr√©sentations** : liste d'adjacence (recommand√©e), matrice d'adjacence\n3. **Parcours** : BFS (file) pour plus court chemin, DFS (pile) pour exploration\n4. **Applications** : r√©seaux sociaux, GPS, IA, optimisation\n5. **Complexit√©** : O(V + E) pour la plupart des algorithmes\n6. **Choix** : orient√©/non orient√©, pond√©r√©/non pond√©r√© selon le probl√®me\n\n---\n\n*Chapitre suivant : [Plus Court Chemin](13-shortest-path.md)*\n"
};

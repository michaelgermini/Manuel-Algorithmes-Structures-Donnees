# Chapitre 12 : Les Graphes

## üåê Probl√®me √† R√©soudre

Certaines donn√©es ne sont pas hi√©rarchiques (comme les arbres) mais **r√©seaut√©es** :

- R√©seaux sociaux ‚Üí amis, abonn√©s
- GPS ‚Üí routes entre villes
- Internet ‚Üí pages li√©es entre elles

üëâ Pour mod√©liser ce type de relations complexes, on utilise les **graphes**.

---

## üìä D√©finition d'un Graphe

Un **graphe** est un ensemble de :

- **Sommets** (n≈ìuds/vertices) : entit√©s (villes, personnes, pages web)
- **Ar√™tes** (edges) : connexions entre sommets

### Types de Graphes

Un graphe peut √™tre :

- **Orient√©** : chaque ar√™te a un sens (ex. Twitter : "je te suis" ‚â† "tu me suis")
- **Non orient√©** : ar√™tes bidirectionnelles (ex. Facebook : "amis")
- **Pond√©r√©** : chaque ar√™te a un co√ªt (distance, temps, poids)
- **Non pond√©r√©** : simple connexion sans co√ªt

### Exemple de Graphe

#### Graphe Non Orient√©
```
   (A) ‚Äî‚Äî (B)
    |     / |
    |    /  |
   (C) ‚Äî‚Äî (D)
```

#### Graphe Orient√©
```
   (A) ‚Üí (B)
    ‚Üì      ‚Üë
   (C) ‚Üí (D)
```

---

## üíæ Repr√©sentation en Informatique

### 1. Liste d'Adjacence (Recommand√©e)

Chaque sommet pointe vers ses voisins.

```javascript
// Graphe non orient√©
const graphe = {
  A: ["B", "C"],
  B: ["A", "D"],
  C: ["A", "D"],
  D: ["B", "C"]
};

// Graphe orient√©
const grapheOriented = {
  A: ["B", "C"],
  B: ["D"],
  C: ["D"],
  D: []
};

// Graphe pond√©r√©
const graphePondere = {
  A: [{sommet: "B", poids: 4}, {sommet: "C", poids: 2}],
  B: [{sommet: "A", poids: 4}, {sommet: "D", poids: 5}],
  C: [{sommet: "A", poids: 2}, {sommet: "D", poids: 1}],
  D: [{sommet: "B", poids: 5}, {sommet: "C", poids: 1}]
};
```

### 2. Matrice d'Adjacence

Tableau 2D o√π matrice[i][j] = 1 si connexion entre i et j.

```javascript
// Pour les sommets A, B, C, D
const matrice = [
  // A  B  C  D
  [ 0, 1, 1, 0 ], // A
  [ 1, 0, 0, 1 ], // B
  [ 1, 0, 0, 1 ], // C
  [ 0, 1, 1, 0 ]  // D
];

// Acc√®s : matrice[0][1] = 1 signifie A connect√© √† B
```

**Comparaison** :
- **Liste** : √©conome en m√©moire pour graphes clairsem√©s
- **Matrice** : acc√®s O(1), mais O(n¬≤) m√©moire m√™me pour graphes vides

---

## üîç Parcours de Graphes

### 1. Parcours en Largeur (BFS - Breadth First Search)

üëâ Explore "couche par couche".

- Utilise une **file** (queue)
- Utile pour trouver le **plus court chemin non pond√©r√©**

```javascript
function parcoursLargeur(graphe, depart) {
  const visites = new Set();
  const file = [];

  file.push(depart);
  visites.add(depart);

  while (file.length > 0) {
    const sommet = file.shift();
    console.log(sommet);

    // Ajouter les voisins non visit√©s
    for (let voisin of graphe[sommet] || []) {
      if (!visites.has(voisin)) {
        visites.add(voisin);
        file.push(voisin);
      }
    }
  }
}

// Exemple
const reseau = {
  A: ["B", "C"],
  B: ["A", "D"],
  C: ["A", "D"],
  D: ["B", "C"]
};

parcoursLargeur(reseau, "A"); // A, B, C, D
```

### 2. Parcours en Profondeur (DFS - Depth First Search)

üëâ Explore "jusqu'au bout d'un chemin" avant de revenir.

- Utilise une **pile** (stack) ou **r√©cursivit√©**
- Utile pour d√©tecter des **cycles**, **composants connexes**

```javascript
function parcoursProfondeur(graphe, sommet, visites = new Set()) {
  if (visites.has(sommet)) return;

  console.log(sommet);
  visites.add(sommet);

  for (let voisin of graphe[sommet] || []) {
    parcoursProfondeur(graphe, voisin, visites);
  }
}

// Version it√©rative
function parcoursProfondeurIteratif(graphe, depart) {
  const visites = new Set();
  const pile = [depart];

  while (pile.length > 0) {
    const sommet = pile.pop();

    if (!visites.has(sommet)) {
      console.log(sommet);
      visites.add(sommet);

      // Ajouter les voisins (dans l'ordre inverse pour garder la logique)
      for (let voisin of (graphe[sommet] || []).reverse()) {
        if (!visites.has(voisin)) {
          pile.push(voisin);
        }
      }
    }
  }
}

parcoursProfondeur(reseau, "A"); // A, B, D, C (selon l'ordre)
```

---

## üîç Applications Pratiques

### 1. R√©seaux Sociaux - Suggestion d'Amis

```javascript
function suggererAmis(graphe, utilisateur, degre = 2) {
  const visites = new Set();
  const suggestions = new Map();

  function explorer(sommet, distance) {
    if (distance > degre || visites.has(sommet)) return;

    visites.add(sommet);

    if (distance > 0 && distance <= degre) {
      suggestions.set(sommet, distance);
    }

    for (let ami of graphe[sommet] || []) {
      explorer(ami, distance + 1);
    }
  }

  explorer(utilisateur, 0);
  suggestions.delete(utilisateur); // Ne pas se sugg√©rer soi-m√™me

  return Array.from(suggestions.entries())
    .sort((a, b) => a[1] - b[1]); // Trier par proximit√©
}

// Exemple
const reseauSocial = {
  Alice: ["Bob", "Charlie"],
  Bob: ["Alice", "Diana", "Eve"],
  Charlie: ["Alice", "Diana"],
  Diana: ["Bob", "Charlie", "Eve"],
  Eve: ["Bob", "Diana"],
  Frank: ["Grace"] // Island
};

console.log(suggererAmis(reseauSocial, "Alice"));
// [["Bob", 1], ["Charlie", 1], ["Diana", 2], ["Eve", 2]]
```

### 2. D√©tection de Cycles

```javascript
function contientCycle(graphe) {
  const visites = new Set();
  const enCours = new Set();

  function dfsCycle(sommet) {
    visites.add(sommet);
    enCours.add(sommet);

    for (let voisin of graphe[sommet] || []) {
      if (!visites.has(voisin)) {
        if (dfsCycle(voisin)) return true;
      } else if (enCours.has(voisin)) {
        return true; // Cycle d√©tect√©
      }
    }

    enCours.delete(sommet);
    return false;
  }

  for (let sommet of Object.keys(graphe)) {
    if (!visites.has(sommet)) {
      if (dfsCycle(sommet)) return true;
    }
  }

  return false;
}

// Test
const grapheAcyclique = {
  A: ["B", "C"],
  B: ["D"],
  C: ["D"],
  D: []
};

const grapheCyclique = {
  A: ["B"],
  B: ["C"],
  C: ["A"] // Cycle A -> B -> C -> A
};

console.log(contientCycle(grapheAcyclique)); // false
console.log(contientCycle(grapheCyclique)); // true
```

### 3. Composants Connexes

```javascript
function composantsConnexes(graphe) {
  const visites = new Set();
  const composants = [];

  function dfs(sommet, composant) {
    visites.add(sommet);
    composant.push(sommet);

    for (let voisin of graphe[sommet] || []) {
      if (!visites.has(voisin)) {
        dfs(voisin, composant);
      }
    }
  }

  for (let sommet of Object.keys(graphe)) {
    if (!visites.has(sommet)) {
      const composant = [];
      dfs(sommet, composant);
      composants.push(composant);
    }
  }

  return composants;
}

// Exemple
const grapheDecconex = {
  A: ["B", "C"],
  B: ["A", "C"],
  C: ["A", "B"],
  D: ["E"],     // Composant s√©par√©
  E: ["D"],
  F: []         // Sommet isol√©
};

console.log(composantsConnexes(grapheDecconex));
// [["A", "B", "C"], ["D", "E"], ["F"]]
```

---

## üíª Exercice Pratique 1

**Objectif** : Impl√©mentez une fonction `hasPath(graph, start, end)` qui retourne `true` si un chemin existe entre `start` et `end`.

Utilisez **DFS** pour la premi√®re version, **BFS** pour la deuxi√®me.

### Solution DFS :
```javascript
function hasPathDFS(graph, start, end, visited = new Set()) {
  if (start === end) return true;
  if (visited.has(start)) return false;

  visited.add(start);

  for (let neighbor of graph[start] || []) {
    if (hasPathDFS(graph, neighbor, end, visited)) {
      return true;
    }
  }

  return false;
}
```

### Solution BFS :
```javascript
function hasPathBFS(graph, start, end) {
  const visited = new Set();
  const queue = [start];
  visited.add(start);

  while (queue.length > 0) {
    const current = queue.shift();

    if (current === end) return true;

    for (let neighbor of graph[current] || []) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
      }
    }
  }

  return false;
}

// Tests
const graph = {
  A: ["B", "C"],
  B: ["A", "D"],
  C: ["A", "D"],
  D: ["B", "C"],
  E: ["F"],
  F: ["E"]
};

console.log(hasPathDFS(graph, "A", "D")); // true
console.log(hasPathBFS(graph, "A", "E")); // false
```

---

## üíª Exercice Pratique 2

**Objectif** : Impl√©mentez une fonction qui trouve le plus court chemin non pond√©r√© entre deux sommets.

### Solution :
```javascript
function plusCourtChemin(graph, start, end) {
  const visited = new Set();
  const queue = [[start, [start]]]; // [sommet, chemin]
  visited.add(start);

  while (queue.length > 0) {
    const [current, path] = queue.shift();

    if (current === end) {
      return path;
    }

    for (let neighbor of graph[current] || []) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push([neighbor, [...path, neighbor]]);
      }
    }
  }

  return null; // Pas de chemin
}

console.log(plusCourtChemin(graph, "A", "D")); // ["A", "B", "D"] ou ["A", "C", "D"]
```

---

### Exercice 3 : D√©tection de Cycles

**Objectif** : Impl√©mentez une fonction qui d√©tecte si un graphe contient un cycle.

**Consignes** :
- Utiliser DFS avec coloriage des n≈ìuds (Blanc, Gris, Noir)
- Un cycle est d√©tect√© si on trouve un arc vers un n≈ìud Gris
- Tester avec diff√©rents graphes

```javascript
function detecteCycle(graph) {
    // TODO: impl√©menter la d√©tection de cycles
}

// Graphes de test
const grapheAcyclique = {
    A: ['B', 'C'],
    B: ['D'],
    C: ['D'],
    D: []
};

const grapheCyclique = {
    A: ['B'],
    B: ['C'],
    C: ['A', 'D'],
    D: []
};

console.log(detecteCycle(grapheAcyclique)); // false
console.log(detecteCycle(grapheCyclique)); // true
```

### Solution :
```javascript
function detecteCycle(graph) {
    const visited = new Set();
    const recStack = new Set();

    function dfs(node) {
        visited.add(node);
        recStack.add(node);

        for (let neighbor of graph[node] || []) {
            if (!visited.has(neighbor)) {
                if (dfs(neighbor)) {
                    return true;
                }
            } else if (recStack.has(neighbor)) {
                // Cycle d√©tect√© !
                return true;
            }
        }

        recStack.delete(node);
        return false;
    }

    // Tester tous les n≈ìuds (au cas o√π le graphe serait d√©connect√©)
    for (let node in graph) {
        if (!visited.has(node)) {
            if (dfs(node)) {
                return true;
            }
        }
    }

    return false;
}

// Tests √©tendus
const tests = [
    {
        name: "Graphe acyclique simple",
        graph: { A: ['B'], B: ['C'], C: [] },
        expected: false
    },
    {
        name: "Graphe avec cycle",
        graph: { A: ['B'], B: ['C'], C: ['A'] },
        expected: true
    },
    {
        name: "Graphe d√©connect√© sans cycle",
        graph: { A: ['B'], B: [], C: ['D'], D: [] },
        expected: false
    },
    {
        name: "Graphe d√©connect√© avec cycle",
        graph: { A: ['B'], B: ['A'], C: ['D'], D: ['C'] },
        expected: true
    }
];

console.log("üåÄ Tests de d√©tection de cycles:");
tests.forEach(test => {
    const result = detecteCycle(test.graph);
    const status = result === test.expected ? "‚úÖ" : "‚ùå";
    console.log(`${status} ${test.name}: ${result} (attendu: ${test.expected})`);
});
```

---

### Exercice 4 : Composantes Connexes

**Objectif** : Trouver toutes les composantes connexes d'un graphe.

**Consignes** :
- Utiliser DFS ou BFS pour explorer chaque composante
- Retourner une liste des composantes
- Tester avec un graphe d√©connect√©

```javascript
function composantesConnexes(graph) {
    // TODO: impl√©menter
}

// Test
const grapheDeconnecte = {
    A: ['B'],
    B: ['A'],
    C: ['D'],
    D: ['C', 'E'],
    E: ['D'],
    F: [] // N≈ìud isol√©
};

console.log(composantesConnexes(grapheDeconnecte));
// R√©sultat attendu: [['A', 'B'], ['C', 'D', 'E'], ['F']]
```

### Solution :
```javascript
function composantesConnexes(graph) {
    const visited = new Set();
    const composantes = [];

    function dfs(node, composante) {
        visited.add(node);
        composante.push(node);

        for (let neighbor of graph[node] || []) {
            if (!visited.has(neighbor)) {
                dfs(neighbor, composante);
            }
        }
    }

    // Parcourir tous les n≈ìuds
    for (let node in graph) {
        if (!visited.has(node)) {
            const composante = [];
            dfs(node, composante);
            composantes.push(composante.sort()); // Trier pour la coh√©rence
        }
    }

    return composantes.sort((a, b) => a.length - b.length); // Trier par taille
}

// Fonction alternative avec BFS
function composantesConnexesBFS(graph) {
    const visited = new Set();
    const composantes = [];

    for (let node in graph) {
        if (!visited.has(node)) {
            const composante = [];
            const queue = [node];
            visited.add(node);

            while (queue.length > 0) {
                const current = queue.shift();
                composante.push(current);

                for (let neighbor of graph[current] || []) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                }
            }

            composantes.push(composante.sort());
        }
    }

    return composantes.sort((a, b) => a.length - b.length);
}

// Tests
const grapheDeconnecte = {
    A: ['B'],
    B: ['A'],
    C: ['D'],
    D: ['C', 'E'],
    E: ['D'],
    F: [] // N≈ìud isol√©
};

console.log("üîó Composantes connexes (DFS):");
console.log(composantesConnexes(grapheDeconnecte));

console.log("üîó Composantes connexes (BFS):");
console.log(composantesConnexesBFS(grapheDeconnecte));

// Test avec graphe vide
console.log("üîó Graphe vide:");
console.log(composantesConnexes({}));

// Test avec un seul n≈ìud
console.log("üîó Un seul n≈ìud:");
console.log(composantesConnexes({ A: [] }));
```

---

### Exercice 5 : Graphe Pond√©r√© - Algorithme de Prim

**Objectif** : Impl√©menter l'algorithme de Prim pour trouver l'arbre couvrant de poids minimal.

**Consignes** :
- Repr√©senter le graphe avec des poids sur les ar√™tes
- Utiliser une file de priorit√© pour s√©lectionner l'ar√™te de poids minimal
- Construire l'arbre couvrant minimum

```javascript
// Repr√©sentation d'un graphe pond√©r√©
const graphePondere = {
    A: [{ vers: 'B', poids: 4 }, { vers: 'C', poids: 2 }],
    B: [{ vers: 'A', poids: 4 }, { vers: 'C', poids: 1 }, { vers: 'D', poids: 5 }],
    C: [{ vers: 'A', poids: 2 }, { vers: 'B', poids: 1 }, { vers: 'D', poids: 8 }],
    D: [{ vers: 'B', poids: 5 }, { vers: 'C', poids: 8 }]
};

function arbreCouvrantPrim(graph, start) {
    // TODO: impl√©menter l'algorithme de Prim
}

console.log(arbreCouvrantPrim(graphePondere, 'A'));
```

### Solution :
```javascript
function arbreCouvrantPrim(graph, start) {
    const mst = []; // Ar√™tes de l'arbre couvrant
    const visited = new Set();
    const minHeap = new PriorityQueue();

    visited.add(start);

    // Ajouter toutes les ar√™tes du n≈ìud de d√©part
    for (let edge of graph[start] || []) {
        minHeap.push({ poids: edge.poids, de: start, vers: edge.vers });
    }

    while (!minHeap.isEmpty() && visited.size < Object.keys(graph).length) {
        const edge = minHeap.pop();

        if (visited.has(edge.vers)) {
            continue; // Cette ar√™te cr√©erait un cycle
        }

        // Ajouter l'ar√™te √† l'arbre couvrant
        mst.push(edge);
        visited.add(edge.vers);

        // Ajouter les nouvelles ar√™tes disponibles
        for (let newEdge of graph[edge.vers] || []) {
            if (!visited.has(newEdge.vers)) {
                minHeap.push({
                    poids: newEdge.poids,
                    de: edge.vers,
                    vers: newEdge.vers
                });
            }
        }
    }

    return mst;
}

// File de priorit√© simple (min-heap)
class PriorityQueue {
    constructor() {
        this.values = [];
    }

    push(element) {
        this.values.push(element);
        this.bubbleUp();
    }

    pop() {
        if (this.values.length === 0) return null;

        const min = this.values[0];
        const end = this.values.pop();

        if (this.values.length > 0) {
            this.values[0] = end;
            this.sinkDown();
        }

        return min;
    }

    bubbleUp() {
        let index = this.values.length - 1;
        const element = this.values[index];

        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            const parent = this.values[parentIndex];

            if (element.poids >= parent.poids) break;

            this.values[parentIndex] = element;
            this.values[index] = parent;
            index = parentIndex;
        }
    }

    sinkDown() {
        let index = 0;
        const length = this.values.length;
        const element = this.values[0];

        while (true) {
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;
            let leftChild, rightChild;
            let swapIndex = null;

            if (leftChildIndex < length) {
                leftChild = this.values[leftChildIndex];
                if (leftChild.poids < element.poids) {
                    swapIndex = leftChildIndex;
                }
            }

            if (rightChildIndex < length) {
                rightChild = this.values[rightChildIndex];
                if (
                    (swapIndex === null && rightChild.poids < element.poids) ||
                    (swapIndex !== null && rightChild.poids < leftChild.poids)
                ) {
                    swapIndex = rightChildIndex;
                }
            }

            if (swapIndex === null) break;

            this.values[index] = this.values[swapIndex];
            this.values[swapIndex] = element;
            index = swapIndex;
        }
    }

    isEmpty() {
        return this.values.length === 0;
    }
}

// Test de l'algorithme de Prim
const graphePondere = {
    A: [{ vers: 'B', poids: 4 }, { vers: 'C', poids: 2 }],
    B: [{ vers: 'A', poids: 4 }, { vers: 'C', poids: 1 }, { vers: 'D', poids: 5 }],
    C: [{ vers: 'A', poids: 2 }, { vers: 'B', poids: 1 }, { vers: 'D', poids: 8 }],
    D: [{ vers: 'B', poids: 5 }, { vers: 'C', poids: 8 }]
};

console.log("üå≤ Arbre couvrant minimum (Prim):");
const mst = arbreCouvrantPrim(graphePondere, 'A');

let totalWeight = 0;
console.log("Ar√™tes de l'arbre couvrant:");
mst.forEach(edge => {
    console.log(`   ${edge.de} --(${edge.poids})-- ${edge.vers}`);
    totalWeight += edge.poids;
});

console.log(`Poids total: ${totalWeight}`);

// V√©rification: devrait √™tre 2 + 1 + 5 = 8
console.log("V√©rification: A-C(2) + B-C(1) + B-D(5) = 8 ‚úì");
```

---

## üìä Analyse de Complexit√©

| Algorithme | Complexit√© Temps | Complexit√© Espace |
|------------|------------------|-------------------|
| **BFS** | O(V + E) | O(V) |
| **DFS** | O(V + E) | O(V) |

O√π :
- **V** = nombre de sommets (vertices)
- **E** = nombre d'ar√™tes (edges)

---

## üåü Cas d'Usage R√©els

- **GPS** (Google Maps, Waze) ‚Üí trouver l'itin√©raire le plus court
- **R√©seaux sociaux** ‚Üí suggestion d'amis
- **IA** (jeux vid√©o) ‚Üí d√©placement de personnages
- **Internet** (PageRank de Google) ‚Üí importance des pages web
- **R√©seaux informatiques** ‚Üí routage des paquets
- **Base de donn√©es** ‚Üí optimisation de requ√™tes

---

## üìù Quiz de R√©vision

### Question 1
Quelle est la diff√©rence entre un graphe orient√© et non orient√© ?
- A) L'orientation change la complexit√©
- B) Les ar√™tes orient√©es sont √† sens unique  ‚Üê **R√©ponse**
- C) Les graphes orient√©s utilisent plus de m√©moire
- D) Aucune diff√©rence pratique

### Question 2
Quelle repr√©sentation est la plus √©conome en m√©moire pour un graphe clairsem√© ?
- A) Matrice d'adjacence
- B) Liste d'adjacence  ‚Üê **R√©ponse**
- C) Liste de successeurs
- D) Tableau de pointeurs

### Question 3
Quel algorithme de parcours est le plus adapt√© pour trouver un plus court chemin non pond√©r√© ?
- A) DFS
- B) BFS  ‚Üê **R√©ponse**
- C) Dijkstra
- D) A*

### Question 4
Dans un graphe, que signifie "V + E" dans la complexit√© ?
- A) Nombre maximum de sommets
- B) Sommets + Ar√™tes  ‚Üê **R√©ponse**
- C) Visites + Explorations
- D) Variables + √âquations

---

## üîë Points Cl√©s √† Retenir

1. **Graphe** = ensemble de sommets connect√©s par des ar√™tes
2. **Repr√©sentations** : liste d'adjacence (recommand√©e), matrice d'adjacence
3. **Parcours** : BFS (file) pour plus court chemin, DFS (pile) pour exploration
4. **Applications** : r√©seaux sociaux, GPS, IA, optimisation
5. **Complexit√©** : O(V + E) pour la plupart des algorithmes
6. **Choix** : orient√©/non orient√©, pond√©r√©/non pond√©r√© selon le probl√®me

---

*Chapitre suivant : [Plus Court Chemin](13-shortest-path.md)*
